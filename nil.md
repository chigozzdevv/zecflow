# nilCC Overview

URL: https://docs.nillion.com/build/compute/overview

## What is nilCC?

nilCC (Nillion Confidential Compute) is a private compute platform where nodes perform developer-specified workflows within Trusted Execution Environments (TEEs). This enables general-purpose private computation over sensitive data through containerized applications.

Developers can deploy any [Docker Compose application](https://docs.docker.com/compose/) with hardware-guaranteed privacy and cryptographic proof of execution integrity, transforming standard workloads into verifiably secure computations.

### Core Capabilities

- **Docker Compatibility** : Run your Docker Compose application - databases, APIs, ML models, analytics pipelines
- **Hardware Security (CPU/GPU)** : [AMD SEV-SNP](https://www.amd.com/en/developer/sev.html) (AMD Secure Encrypted Virtualization-Secure Nested Paging) provides memory encryption and isolation for CPU workloads. GPU-enabled machines support NVIDIA Confidential Compute with additional GPU attestation.
- **Cryptographic Verification** : Hardware-generated attestation reports prove workload integrity. CPU configurations are verified through AMD SEV-SNP measurements, and GPU machines provide NVIDIA attestation tokens.
- **Complete Isolation** : Each workload runs in its own Confidential VM, protected from host and other workloads
- **Resource Allocation** : CPU and memory resources are tracked and allocated by [nilcc-agent](/build/compute/architecture#nilcc-agent) to prevent overcommitment. GPU resources are available on supported machines for enhanced computational capabilities.

### Why Use nilCC?

Traditional cloud computing requires trusting the infrastructure provider with your code and data. nilCC eliminates this trust requirement by using hardware-level security that even the infrastructure provider cannot bypass, enabling you to process sensitive data with cryptographic proof of integrity.
We encourage you to extend these security guarantees to your users. Workloads running on nilCC cannot be accessed by the machine administrator or by the developer, powered by the same cryptographic attestation. By making the source code publicly available your users can also confirm the integrity of the workload and feel confident that their data is safe and secure.

## How Does nilCC Work?

nilCC operates through a simple process: you submit a Docker Compose file, nilCC creates a secure Confidential VM to run it, and provides cryptographic attestation that proves your workload runs unmodified.

### Confidential VMs (CVMs)

Confidential VMs (CVMs) are virtual machines that leverage [AMD SEV-SNP](https://www.amd.com/en/developer/sev.html) to run workloads, in the form of docker compose files, in a secure and verifiable way. All CVMs include a [Caddy](https://caddyserver.com/) instance that will act as a proxy to a specific container in the compose setup and will handle TLS certificate generation for it via [ZeroSSL](https://zerossl.com/) .

**Example: nilCC Docker Compose for a Caddy-based API service**

```yaml
services:
  web:
    image: caddy:2
    command: |
      caddy respond --listen :8080 --body '{"hello":"world"}' --header "Content-Type: application/json"
```

This becomes a secure, attestable workload with automatic TLS and hardware protection.

### Integrity and Verification

Confidential VMs provide a means to retrieve a hardware generated attestation, that can then be used to ensure that:

- The contents of the filesystem at boot time are the expected ones
- The virtual machine is running the expected docker compose file

#### dm-verity

The filesystem used to boot the VM is verified using [`dm-verity`](https://docs.kernel.org/admin-guide/device-mapper/verity.html) , which allows proving that its contents haven't been tampered with. The VM disk's merkle tree and root hash are verified during boot to ensure the filesystem hasn't been tampered with.

### Attestation Reports

Attestation reports, as generated by AMD SEV-SNP, contain a measurement hash which is derived from:

- The kernel being used
- The initrd image used during boot
- The Open Virtual Machine Firmware (OVMF) that VM uses
- The parameters passed to the kernel when launching the VM
- The number of vCPUs attached to the VM

### Secure Boot and Workload Validation

nilCC ensures workload integrity through a secure boot process. The custom initrd image:

- Mounts the `dm-verity` disk and ensures its integrity using the root hash provided as a kernel parameter
- Creates a squashfs filesystem on a disk that is attached during boot and encrypts it via LUKS using a random key. This disk is mounted on `/var` to allow docker compose to work with a read-only root filesystem
- Ensures the docker compose that's part of the workload is being ran by sha256-hashing the docker compose file and comparing it with the expected hash passed as a kernel parameter

## Resources

- **nilCC Source Code** : [https://github.com/NillionNetwork/nilcc](https://github.com/NillionNetwork/nilcc)
- **nilCC Workload Manager** : [https://nilcc.nillion.com](https://nilcc.nillion.com)

# nilCC Quickstart

URL: https://docs.nillion.com/build/compute/quickstart

Get started with nilCC in under 5 minutes by deploying your first secure workload.

info
Before you start building, you'll need a nilCC API Key. Request a **nilCC API Key** by filling out [this form](https://surveys.nillion.com/developers/07089b92-f409-4b65-b825-d61132971869)

## Deploy Your First Workload

Let's deploy a simple "Hello World" API service that runs in a secure Confidential VM.

### Step 1: Create Your Docker Compose File

Create a simple API service:

```yaml
services:
  web:
    image: caddy:2
    command: |
      caddy respond --listen :8080 --body '{"hello":"world"}' --header "Content-Type: application/json"
```

### Step 2: Create Workload

Choose your preferred workload creation method. Both options create the same secure workload

- Create Workload with UI
- Create Workload with API
Create a new workload with the [nilCC Workload Manager](https://nilcc.nillion.com) UI. This workload creation method is recommended for first-time nilCC users, visual workflow management, and ongoing monitoring.

[![nilCC Create Workload](/assets/images/nilcc-create-workload-88ddc17b912092fa276fc922381ae5f2.png)](https://nilcc.nillion.com/workloads/create)

1. **Visit** : [nilCC Workload Manager](https://nilcc.nillion.com)
2. **Authenticate** : Enter your nilCC API Key to log in
3. **Create New Workload** :
- **Name** : `hello-world-api`
- **Docker Compose** : Paste the YAML content from Step 1
- **Service to Expose** : `web` (automatically detected)
- **Port** : `8080` (automatically detected)
- **Resources** : Optionally adjust the resource tier as needed
4. **Name** : `hello-world-api`
5. **Docker Compose** : Paste the YAML content from Step 1
6. **Service to Expose** : `web` (automatically detected)
7. **Port** : `8080` (automatically detected)
8. **Resources** : Optionally adjust the resource tier as needed
9. **Deploy** : Click "Create Workload" and monitor the deployment status in real-time

Create a new workload programatically with the nilCC API. This workload creation method is recommended for automation, CI/CD pipelines, and programmatic deployments.

Update the command below with your nilCC API key, chosen resource tier (cpus, gpus, memory, and disk size), and the latest artifacts version:

```bash
curl -X POST https://api.nilcc.nillion.network/api/v1/workloads/create \
  -H "x-api-key: YOUR_API_KEY" \
  -H "Content-Type: application/json" \
  -d '{
    "name": "hello-world-api",
    "dockerCompose": "services:\n  web:\n    image: caddy:2\n    command: |\n      caddy respond --listen :8080 --body '\''{\"hello\":\"world\"}'\'' --header \"Content-Type: application/json\"",
    "serviceToExpose": "web",
    "servicePortToExpose": 8080,
    "cpus": YOUR_CPUS,
    "memory": YOUR_MEMORY,
    "disk": YOUR_DISK,
    "gpus": YOUR_GPUS,
    "artifactsVersion": LATEST_ARTIFACTS_VERSION
  }'
```

**Key API Parameters:**

- `dockerCompose` : Your Docker Compose file as an escaped string
- `serviceToExpose` : Which service gets the public domain (must match a service name)
- `servicePortToExpose` : Which port on that service to expose publicly
- `artifactsVersion` : nilCC VM image version

## Test Your Workload

### Access Your Secure API within nilCC

Once deployed, your workload gets a unique domain. Access it at:

```bash
# Your workload will be available at a domain like:
curl https://[your-running-workload]
```

Expected response:

```json
{ "hello": "world" }
```

### Verify Security (Check Attestation)

Prove your workload runs in a secure TEE:

```bash
curl https://[your-running-workload]/nilcc/api/v2/report
```

This returns a cryptographic attestation report proving:

- Your code runs unmodified in a genuine [AMD SEV-SNP](https://www.amd.com/en/developer/sev.html) environment
- No unauthorized access to your workload
- Hardware-guaranteed isolation and encryption

## What Happens Behind the Scenes

When you deploy a workload, nilCC:

1. **Creates a Confidential VM** with [AMD SEV-SNP](https://www.amd.com/en/developer/sev.html) hardware security
2. **Packages your workload** as an ISO with docker-compose.yaml, metadata, and environment variables
3. **Boots securely** with dm-verity filesystem verification and LUKS encryption
4. **Deploys containers** with automatic TLS certificates via Caddy
5. **Generates attestation** linking your TLS certificate to hardware measurements

## Next Steps

üéâ **Congratulations!** You've deployed your first secure workload on nilCC.

**Learn More:**

- [Understand security constraints](/build/compute/limitations) - What you can and can't do
- [Explore the architecture](/build/compute/architecture) - How nilCC components work together
- [Browse API documentation](/build/compute/api-reference) - Complete endpoint reference
- [Check key terms](/build/compute/key-terms) - Essential nilCC vocabulary
**Build Something Real:**

- Deploy a secure database with persistent storage
- Run private analytics on sensitive data
- Create confidential microservices
- Build AI/ML workloads with GPU support

# nilCC Quickstart

URL: https://docs.nillion.com/build/compute/quickstart

Get started with nilCC in under 5 minutes by deploying your first secure workload.

info
Before you start building, you'll need a nilCC API Key. Request a **nilCC API Key** by filling out [this form](https://surveys.nillion.com/developers/07089b92-f409-4b65-b825-d61132971869)

## Deploy Your First Workload

Let's deploy a simple "Hello World" API service that runs in a secure Confidential VM.

### Step 1: Create Your Docker Compose File

Create a simple API service:

```yaml
services:
  web:
    image: caddy:2
    command: |
      caddy respond --listen :8080 --body '{"hello":"world"}' --header "Content-Type: application/json"
```

### Step 2: Create Workload

Choose your preferred workload creation method. Both options create the same secure workload

- Create Workload with UI
- Create Workload with API
Create a new workload with the [nilCC Workload Manager](https://nilcc.nillion.com) UI. This workload creation method is recommended for first-time nilCC users, visual workflow management, and ongoing monitoring.

[![nilCC Create Workload](/assets/images/nilcc-create-workload-88ddc17b912092fa276fc922381ae5f2.png)](https://nilcc.nillion.com/workloads/create)

1. **Visit** : [nilCC Workload Manager](https://nilcc.nillion.com)
2. **Authenticate** : Enter your nilCC API Key to log in
3. **Create New Workload** :
- **Name** : `hello-world-api`
- **Docker Compose** : Paste the YAML content from Step 1
- **Service to Expose** : `web` (automatically detected)
- **Port** : `8080` (automatically detected)
- **Resources** : Optionally adjust the resource tier as needed
4. **Name** : `hello-world-api`
5. **Docker Compose** : Paste the YAML content from Step 1
6. **Service to Expose** : `web` (automatically detected)
7. **Port** : `8080` (automatically detected)
8. **Resources** : Optionally adjust the resource tier as needed
9. **Deploy** : Click "Create Workload" and monitor the deployment status in real-time

Create a new workload programatically with the nilCC API. This workload creation method is recommended for automation, CI/CD pipelines, and programmatic deployments.

Update the command below with your nilCC API key, chosen resource tier (cpus, gpus, memory, and disk size), and the latest artifacts version:

```bash
curl -X POST https://api.nilcc.nillion.network/api/v1/workloads/create \
  -H "x-api-key: YOUR_API_KEY" \
  -H "Content-Type: application/json" \
  -d '{
    "name": "hello-world-api",
    "dockerCompose": "services:\n  web:\n    image: caddy:2\n    command: |\n      caddy respond --listen :8080 --body '\''{\"hello\":\"world\"}'\'' --header \"Content-Type: application/json\"",
    "serviceToExpose": "web",
    "servicePortToExpose": 8080,
    "cpus": YOUR_CPUS,
    "memory": YOUR_MEMORY,
    "disk": YOUR_DISK,
    "gpus": YOUR_GPUS,
    "artifactsVersion": LATEST_ARTIFACTS_VERSION
  }'
```

**Key API Parameters:**

- `dockerCompose` : Your Docker Compose file as an escaped string
- `serviceToExpose` : Which service gets the public domain (must match a service name)
- `servicePortToExpose` : Which port on that service to expose publicly
- `artifactsVersion` : nilCC VM image version

## Test Your Workload

### Access Your Secure API within nilCC

Once deployed, your workload gets a unique domain. Access it at:

```bash
# Your workload will be available at a domain like:
curl https://[your-running-workload]
```

Expected response:

```json
{ "hello": "world" }
```

### Verify Security (Check Attestation)

Prove your workload runs in a secure TEE:

```bash
curl https://[your-running-workload]/nilcc/api/v2/report
```

This returns a cryptographic attestation report proving:

- Your code runs unmodified in a genuine [AMD SEV-SNP](https://www.amd.com/en/developer/sev.html) environment
- No unauthorized access to your workload
- Hardware-guaranteed isolation and encryption

## What Happens Behind the Scenes

When you deploy a workload, nilCC:

1. **Creates a Confidential VM** with [AMD SEV-SNP](https://www.amd.com/en/developer/sev.html) hardware security
2. **Packages your workload** as an ISO with docker-compose.yaml, metadata, and environment variables
3. **Boots securely** with dm-verity filesystem verification and LUKS encryption
4. **Deploys containers** with automatic TLS certificates via Caddy
5. **Generates attestation** linking your TLS certificate to hardware measurements

## Next Steps

üéâ **Congratulations!** You've deployed your first secure workload on nilCC.

**Learn More:**

- [Understand security constraints](/build/compute/limitations) - What you can and can't do
- [Explore the architecture](/build/compute/architecture) - How nilCC components work together
- [Browse API documentation](/build/compute/api-reference) - Complete endpoint reference
- [Check key terms](/build/compute/key-terms) - Essential nilCC vocabulary
**Build Something Real:**

- Deploy a secure database with persistent storage
- Run private analytics on sensitive data
- Create confidential microservices
- Build AI/ML workloads with GPU support

# nilCC Architecture

URL: https://docs.nillion.com/build/compute/architecture

## System Overview

nilCC is a distributed system composed of several interconnected components that work together to provide secure, verifiable computation in Trusted Execution Environments. The architecture is designed to separate concerns between workload management, secure execution, and user interaction.

![nilCC Components](/assets/images/nilcc-b839fd37049e481c582c3b07126c5197.jpg)

## Core Components

### nilcc-agent

The [nilcc-agent](https://github.com/NillionNetwork/nilcc/tree/main/nilcc-agent) is the workload orchestrator that runs on each bare metal machine in the nilCC infrastructure. It serves as the bridge between the public API and the actual Confidential VMs.

#### Responsibilities

- **CVM Lifecycle Management** : Creates, starts, stops, and deletes Confidential VMs based on workload requirements
- **Resource Management** : Tracks CPU, memory, GPU, and disk allocation to prevent overcommitment
- **Monitoring & Reporting** : Monitors VM health and reports status/errors to nilcc-api
- **Log & Metrics Collection** : Retrieves logs and system statistics from running CVMs

#### Communication

- **Upward to nilcc-api** : Registers on startup with a unique API token for authenticated communication
- **Downward to cvm-agent** : Communicates with each VM's cvm-agent via a local-only HTTP API
- **Security** : All API communication uses authentication tokens passed in HTTP headers

### nilcc-attester

The [nilcc-attester](https://github.com/NillionNetwork/nilcc/tree/main/nilcc-attester) runs as a container within each CVM's Docker Compose setup, providing automatic attestation generation made available through an API.

#### Key Features

- **Automatic Attestation Generation** : Generates [AMD SEV-SNP](https://www.amd.com/en/developer/sev.html) attestations on startup
- **GPU Support** : Additionally generates NVIDIA Confidential Compute attestations on GPU-enabled machines
- **Public Endpoint** : Exposes attestation reports at `/nilcc/api/v2/report`
- **TLS Integration** : Links attestation to the workload's TLS certificate fingerprint

#### Attestation Verification Flow

1. **Client requests attestation report** from the public endpoint
2. **Validates the attestation** including signature verification and certificate chain validation with AMD's public key
3. **Verifies TLS fingerprint match** between the HTTPS connection and attestation data
4. **Ensures authenticity** by confirming the client is communicating with the attested machine
This design prevents man-in-the-middle attacks and provides cryptographic proof of the execution environment.

### cvm-agent

The [cvm-agent](https://github.com/NillionNetwork/nilcc/tree/main/cvm-agent) runs as a systemd daemon inside each Confidential VM, managing the actual workload execution within the secure environment.

#### Core Functions

- **Docker Compose Management** : Launches and manages the user's containerized workload
- **Log Collection** : Provides access to both cvm-agent logs and container logs
- **System Monitoring** : Exposes CPU, memory, disk, and other system statistics
- **Container Health Monitoring** : Monitors container status and reports issues

#### Security Design

- **Local-only API** : HTTP API is only accessible within the bare metal machine, not publicly exposed
- **Controlled Access** : Only communicates with the nilcc-agent on the same physical host
- **Bootstrap Security** : Waits for authenticated bootstrap request before starting workloads

#### Bootstrap Process

The bootstrap process ensures secure workload initialization with proper credentials and configuration.

**Initialization Phase**

1. `cvm-agent` starts but waits for bootstrap request from `nilcc-agent`
2. Bootstrap request includes:
- Docker Hub credentials (read-only access to avoid rate limits)
- ZeroSSL credentials for TLS certificate generation
- User-provided private registry credentials (if any)
3. Docker Hub credentials (read-only access to avoid rate limits)
4. ZeroSSL credentials for TLS certificate generation
5. User-provided private registry credentials (if any)
**Workload Deployment Phase**

1. **Authentication** : Perform `docker login` with all provided credentials
2. **Image Preparation** : Run `docker compose pull` to download all required images
3. **Service Startup** : Execute `docker compose up` with:
- User's workload configuration
- Caddy proxy container (for TLS termination)
- nilcc-attester container (for attestation)
4. User's workload configuration
5. Caddy proxy container (for TLS termination)
6. nilcc-attester container (for attestation)
7. **Certificate Monitoring** : Monitor Caddy for successful TLS certificate generation
8. **Operational Mode** : Switch to log/stats serving once TLS is established
This staged approach provides better error handling and ensures all components are properly configured before workload execution begins.

### nilcc-api

The [nilcc-api](https://github.com/NillionNetwork/nilcc/tree/main/nilcc-api) serves as the central control plane, providing the public interface for workload management and coordination across the entire nilCC infrastructure.

#### Primary Functions

- **User Interface** : Provides REST API endpoints for workload creation, management, and monitoring
- **Agent Coordination** : Orchestrates multiple nilcc-agent instances across different bare metal hosts
- **Event Processing** : Receives and processes status updates, errors, and events from agents
- **Resource Allocation** : Makes decisions about workload placement based on available resources

#### Integration Points

- **Upward to Users/UI** : Serves the nilcc-ui dashboard and external API clients
- **Downward to Agents** : Communicates with registered nilcc-agent instances using authentication tokens
This centralized design allows users to manage workloads across multiple physical hosts through a single, consistent API while maintaining security through token-based authentication.

# nilCC Key Terms

URL: https://docs.nillion.com/build/compute/key-terms

This glossary defines key terms as they are used throughout the nilCC documentation and system.

## Bare Metal

Physical server hardware that hosts the nilCC infrastructure. Each bare metal machine runs a single `nilcc-agent` instance that manages multiple Confidential VMs on that physical host. The bare metal machine provides the [AMD SEV-SNP](https://www.amd.com/en/developer/sev.html) hardware security features that enable confidential computing.

## TEE (Trusted Execution Environment)

A secure area of a processor that provides hardware-level isolation and encryption for code and data. In nilCC, TEEs are implemented using [AMD SEV-SNP](https://www.amd.com/en/developer/sev.html) technology, which creates secure enclaves where workloads can run with cryptographic proof that they haven't been tampered with or accessed by unauthorized parties, including the infrastructure provider.

## CVM (Confidential VM)

A virtual machine that leverages [AMD SEV-SNP](https://www.amd.com/en/developer/sev.html) to run workloads in a secure and verifiable way. Each CVM:

- Runs a single workload in the form of Docker Compose files
- Includes a Caddy instance for TLS certificate generation and proxy services
- Provides complete isolation from the host system and other VMs
- Generates hardware attestation reports to prove execution integrity
- Has its own dedicated resources (CPU, memory, disk)
CVMs are managed by the `nilcc-agent` on the bare metal host and run a `cvm-agent` daemon internally to manage the workload execution.

## Workload

A containerized application defined by a Docker Compose file that runs inside a CVM. Workloads in nilCC:

- Are deployed as ISO files containing the Docker Compose configuration, metadata, and environment variables
- Can be any type of application (databases, APIs, ML models, analytics pipelines, etc.)
- Run with hardware-guaranteed privacy and security
- Receive automatic TLS certificates and attestation capabilities
- Are completely isolated from other workloads and the host system
Each workload gets its own dedicated CVM and can be managed through the nilCC API (create, start, stop, restart, delete) with full lifecycle control.

## CPU/GPU

nilCC uses both CPU and GPU resources for confidential computation:

**CPU** : CVMs leverage [AMD SEV-SNP](https://www.amd.com/en/developer/sev.html) technology for secure execution. CPU resources are allocated and tracked by nilcc-agent to prevent overcommitment. The number of vCPUs attached to each VM is included in the [AMD SEV-SNP](https://www.amd.com/en/developer/sev.html) attestation report measurement, allowing verification of the exact CPU configuration.

**GPU** : nilCC supports GPU-enabled machines for enhanced computational capabilities. On GPU machines, nilcc-attester will generate an NVIDIA Confidential Compute attestation in addition to the [AMD SEV-SNP](https://www.amd.com/en/developer/sev.html) attestation. GPU resources are tracked and allocated by the system alongside CPU and memory resources.

## nilCC Components

See [nilCC Architecture](/build/compute/architecture)

- **nilcc-agent** : Runs on bare metal machines to manage CVMs and workloads
- **cvm-agent** : Runs inside each CVM to manage Docker Compose workload execution
- **nilcc-attester** : Generates TEE attestations within each CVM
- **nilcc-api** : Public API for workload and system management

# nilCC API Reference

URL: https://docs.nillion.com/build/compute/api-reference

The nilCC API provides comprehensive programmatic access to create and manage confidential workloads. All endpoints are documented using OpenAPI 3.0 specifications with automatic generation from the source code.

## Accessing the API Documentation

### Live OpenAPI Specification

The complete API documentation is available as an interactive [OpenAPI specification](https://api.nilcc.nillion.network/openapi.json)

```text
https://api.nilcc.nillion.network/openapi.json
```

### Interactive Documentation

You can explore the API using any OpenAPI-compatible tool:

1. **Swagger Validator** : Paste the OpenAPI spec URL into [validator.swagger.io](https://validator.swagger.io)
2. **Postman** : Import the OpenAPI spec to generate a collection
3. **curl** : Use the examples provided in the specification

## Authentication

All API endpoints require authentication via the `x-api-key` header:

```bash
curl -X POST https://api.nilcc.nillion.network/api/v1/workloads/create \
  -H "x-api-key: YOUR_API_KEY" \
  -H "Content-Type: application/json"
```

## Core API Groups

The API is organized into several functional groups:

### Workloads

```text
/api/v1/workloads/*
```

- **Create** : Deploy new confidential workloads
- **List** : View all your workloads
- **Manage** : Start, stop, restart, and delete workloads
- **Monitor** : Access logs and system statistics

### Workload Containers

```text
/api/v1/workload-containers/*
```

- **List** : View containers within a workload
- **Logs** : Access individual container logs

### Accounts

```text
/api/v1/accounts/*
```

- **Profile** : Manage your account information
- **Credits** : Add and manage account credits

### Metal Instances

```text
/api/v1/metal-instances/*
```

- **Infrastructure** : Register and manage bare metal hosts (admin)

### Artifacts

```text
/api/v1/artifacts/*
```

- **System** : Manage nilCC system artifacts and versions

## Example API Workflow

Here's a typical workflow for deploying a workload:

1. **Check Available nilCC Resources**
List the available workload tiers to see what resource configurations are offered:

```bash
curl -X GET https://api.nilcc.nillion.network/api/v1/workload-tiers/list \
  -H "x-api-key: YOUR_API_KEY" \
  -H "accept: application/json"
```

This returns available workload tiers - predefined resource configurations including CPU cores, memory (MB), disk storage (GB), GPUs, cost (credits), and tier ID. When creating a workload, your cpus, memory, disk, and gpus parameters must match one of the available tiers.

1. **List Available Artifacts**
Check which VM image versions are available to select the latest

```bash
curl -X GET https://api.nilcc.nillion.network/api/v1/artifacts/list \
  -H "x-api-key: YOUR_API_KEY" \
  -H "accept: application/json"
```

This returns the available artifact versions you can use in the `artifactsVersion` parameter when creating workloads.

1. **Create a workload** :

```bash
curl -X POST https://api.nilcc.nillion.network/api/v1/workloads/create \
  -H "x-api-key: YOUR_API_KEY" \
  -H "Content-Type: application/json" \
  -d '{
    "name": "my-favorite-workload",
    "artifactsVersion": "ARTIFACTS_VERSION",
    "dockerCompose": "services:\n  api:\n    image: caddy:2\n    command: |\n      caddy respond --listen :80 --body '\''{\"hi\":\"foo\"}'\'' --header \"Content-Type: application/json\"",
    "envVars": {
      "FOO": "42"
    },
    "files": {
      "foo/bar.txt": "BASE64_ENCODED_CONTENT"
    },
    "dockerCredentials": [
      {
        "server": "registry.example.com",
        "username": "username",
        "password": "password"
      }
    ],
    "publicContainerName": "api",
    "publicContainerPort": 80,
    "memory": MEMORY_MB,
    "cpus": CPU_CORES,
    "disk": DISK_GB,
    "gpus": GPU_COUNT
  }'
```

1. **Check workload status** :

```bash
curl -X POST https://api.nilcc.nillion.network/api/v1/workloads/list \
  -H "x-api-key: YOUR_API_KEY"
```

1. **Get workload logs** :

```bash
curl -X POST https://api.nilcc.nillion.network/api/v1/workloads/logs \
  -H "x-api-key: YOUR_API_KEY" \
  -d '{"workloadId": "your-workload-id"}'
```

1. **Access attestation report** (from your running workload):

```bash
curl https://[your-running-workload]/nilcc/api/v2/report
```

## Response Format

All API responses follow a consistent format with proper HTTP status codes:

- **200** : Success with data
- **201** : Created successfully
- **400** : Bad request (validation errors)
- **401** : Unauthorized (invalid API key)
- **404** : Resource not found
- **500** : Internal server error
Error responses include detailed messages and validation information to help troubleshoot issues.

## Rate Limits and Quotas

API usage may be subject to rate limits and account quotas. Check your account status via the `/api/v1/accounts/me` endpoint for current usage and limits.

## Support

- **[OpenAPI Spec](https://api.nilcc.nillion.network/openapi.json)** : The API documentation is automatically generated from the source code, so the spec should stay up to date with the latest API changes
- **Code Examples** : Available in the OpenAPI specification and within the nilcc [blind-module-examples](https://github.com/NillionNetwork/blind-module-examples)
- **nilCC Source Code** : [https://github.com/NillionNetwork/nilcc](https://github.com/NillionNetwork/nilcc)

# nilCC Limitations

URL: https://docs.nillion.com/build/compute/limitations

These restrictions are in place to prevent access to sensitive system credentials and ensure secure container execution.

## File System & Storage

- **Custom filesystem drivers are not supported**

- Only standard filesystem types are allowed
- No custom or experimental filesystem drivers can be used
- **Volume mounts must start with `$FILES` or `${FILES}`**

- All file access is restricted to your designated directory
- Example: `$FILES/data:/app/data` ‚úì
- Example: `/home/user/data:/app/data` ‚úó
- **No path traversal ( `../` ) to access parent directories**

- Cannot use relative paths to escape the designated directory
- All paths must remain within the allowed file space
- **Simple volume syntax only**

- Format must be `source:destination`
- No advanced volume options or configurations
- No bind propagation options
- **Environment files follow the same path restrictions**

- `.env` files must be in the allowed directory
- Cannot reference environment files outside `$FILES`

## Container Security Restrictions

- **No privileged containers**

- `privileged: true` is not allowed
- Containers run with standard permissions only
- **No additional capabilities ( `cap_add` )**

- Cannot grant additional Linux capabilities to containers
- Containers run with default capability set only
- **No device mounting**

- Cannot mount host devices into containers
- No access to `/dev` devices from the host
- **No shared namespaces with host**

- `network_mode: host` is not allowed
- `pid_mode: host` is not allowed
- `ipc_mode: host` is not allowed
- Containers remain isolated from host namespaces
- **No security option overrides ( `security_opt` )**

- Cannot disable security features
- Cannot modify AppArmor or SELinux contexts
- Standard security policies are enforced

## Docker Compose Features

- **No external file dependencies**

- `extends` with external files is not supported
- `include` directives for external compose files are not allowed
- All configuration must be self-contained
- **No Docker secrets**

- The `secrets` configuration is not supported
- Use environment variables or mounted files instead
- Example: Pass secrets via environment variables or `.env` files
- **No custom network drivers or advanced networking**

- Cannot specify custom network drivers
- No driver options configuration
- No manual IP address management
- Default bridge networking is used
- **No cgroup modifications**

- Cannot set custom cgroup rules
- No resource limit modifications beyond standard CPU/memory
- System manages cgroups automatically

## Why These Limitations?

These restrictions ensure:

1. **Security Isolation** : Workloads cannot access host system resources or escape their designated environment
2. **Attestation Integrity** : The measurement and verification process remains reliable and tamper-proof
3. **Multi-tenancy Safety** : Multiple workloads can run safely on the same infrastructure without interference
4. **Credential Protection** : System credentials and secrets remain protected from workload access

## Working Within Limitations

Despite these restrictions, you can still:

- Run complex multi-container applications
- Use any programming language or framework
- Store and process data within your designated space
- Connect containers within your workload
- Access external services and APIs
- Use GPU resources (when allocated)
Most applications require minimal or no changes to work within these constraints. The limitations primarily affect edge cases that would compromise security rather than typical application functionality.

# Private Storage with nilDB

URL: https://docs.nillion.com/build/private-storage/overview

## What is Private Storage

Nillion's decentralized storage system keeps sensitive data secret by storing encrypted shares across a cluster of nilDB nodes. Each nilDB node stores a separate share of the encrypted data, ensuring no single node can reveal the original value.

This approach offers stronger security than traditional databases where all data sits in one place. Because secretvaults splits sensitive data between nodes, a breach of any single node only reveals a useless share. You need to combine multiple shares to reconstruct and decrypt the original data.

## How it Works

Private storage is enabled using Nillion's [blindfold libraries](/build/private-storage/blindfold) (which implement secret sharing) and Nillion's [secretvaults SDKs](/build/private-storage/secretvaults) (which simplify interacting with nilDB clusters).

1. **Data Encryption** : Sensitive fields are encrypted using cryptographic keys
2. **Share Generation** : Encrypted data is mathematically split into multiple shares
3. **Distributed Storage** : Each nilDB node stores only one share of the encrypted data
4. **Secure Retrieval** : Multiple shares must be combined to reconstruct the original data
5. **Automatic Decryption** : The secretvaults libraries handle share recombination and decryption from nilDB nodes

## How to Use Private Storage

Interact with the private storage solution using the TypeScript or Python [secretvaults libraries](/build/private-storage/secretvaults) . First register as a builder or user, define data collections, then securely store and retrieve data.

**For Builders (Applications)**

- Get a [Nillion API Key](/build/network-api-access) to connect to nilDB nodes
- Define collections with schemas programmatically or by using the no-code, visual, **[Collection Explorer Tool](/build/private-storage/collection-explorer) (recommended)**
- Store and query data
- Create aggregation queries
**For Users (Data Owners)**

- Connect to a nilDB cluster
- Store private data with access controls
- Manage permissions on your data
- Grant and revoke access

## Key Concepts

### Builder

An application or service that manages collections and data. Builders have access to authentication services and can create both standard and owned collections. They can issue delegation tokens to users for specific operations.

### User

An individual who owns private data stored in owned collections. Users control access permissions through ACLs and maintain sovereignty over their personal data.

### Cluster

A group of nilDB nodes that work together to store data. The cluster provides redundancy, security through distributed shares, and consistency across operations.

### Node

An endpoint where data shares are stored. Each node:

- Stores complete plaintext data for non-encrypted fields
- Holds one encrypted share of sensitive field values
- Is identified by a unique DID (Decentralized Identifier)
- Requires authentication tokens for access
- Cannot independently decrypt sensitive data

### DID (Decentralized Identifier)

A unique cryptographic identifier for builders, users, and nodes. Format: `did:nil:[66-character-hex-string]` . Derived from public keys for verifiable authentication.

### NUC Tokens

JWT-based tokens for API authentication. These are node-specific, time-limited, cryptographically signed, and support delegation between builders and users.

### Collection

A structured container for related data records. Collections have:

- **Owner** : The builder's DID who created it
- **Type** : Either "standard" or "owned"
- **Schema** : JSON Schema defining structure and validation
- **Name** : Human-readable identifier
Collections are immutable once created.

### Collection Types

**Standard Collections**

- Managed by builders
- Used for application data
- Can contain encrypted or plaintext data
- Support indexing and queries
**Owned Collections**

- Store user-owned private data
- Each document has individual ACLs
- Users control access permissions
- Support fine-grained permission types
- üöß Note: User Owned Collections are not fully supported by the [Collection Explorer Tool](/build/private-storage/collection-explorer)

### Schema

A JSON Schema defines the immutable structure of records in a Collection including field names, data types, required fields, formats, and validation rules.

### Record

A single data entry that follows a collection's schema. Plaintext fields are stored identically across nodes, while encrypted fields are split into unique shares per node.

### Field Types

**Plaintext Fields**

- Stored as-is across all nodes
- Visible to anyone with collection access
- Used for non-sensitive metadata
**Encrypted Fields**

- Marked with `{ "%allot": "sensitive-value" }`
- Automatically encrypted and split into shares
- Each node stores a different mathematical share
- Requires multiple nodes to reconstruct

### Access Control (Owned Collections)

**ACL (Access Control List)** Each document in an owned collection has individual permissions:

- **Grantee** : DID of the entity being granted access
- **Read** : Permission to retrieve and decrypt the document
- **Write** : Permission to modify the document
- **Execute** : Permission to run queries on this document
Users can grant and revoke permissions at any time. Each document maintains its own independent ACL.

### Query System

MongoDB-style aggregation pipelines are supported, including stages such as `$match` , `$group` , `$count` , `$lookup` , and `$project` . **Queries can operate on plaintext record values** within Private Storage and support variables for parameterization.

#### Query Variables

Allow parameterization of saved queries using JSONPath syntax to specify substitution points, enabling reusable query templates.

#### Query Examples

We provide string and number field query examples based on the plaintext [name (string) field](https://github.com/NillionNetwork/blind-module-examples/blob/main/nildb/secretvaults-ts/sdk-examples/schema-examples.ts#L11-L13) and the plaintext [age (number) field](https://github.com/NillionNetwork/blind-module-examples/blob/main/nildb/secretvaults-ts/sdk-examples/schema-examples.ts#L14-L16) in the [Example Contact Book Collection Schema](https://github.com/NillionNetwork/blind-module-examples/blob/main/nildb/secretvaults-ts/sdk-examples/schema-examples.ts) .

- [Queries on String Fields](https://github.com/NillionNetwork/blind-module-examples/blob/main/nildb/secretvaults-ts/sdk-examples/query-examples-string.ts)
- [Queries on Number Fields](https://github.com/NillionNetwork/blind-module-examples/blob/main/nildb/secretvaults-ts/sdk-examples/query-examples-number.ts)

# Quickstart

URL: https://docs.nillion.com/build/private-storage/quickstart

warning
If you are using `secretvaults-ts` , please upgrade to at least version `0.1.7`

This guide walks you through building a Node.js demo app that uses Nillion's private storage with user-owned collections.

tip
Reference the full Secretvaults-ts docs while you build: [SecretVaults TypeScript Docs](/build/private-storage/ts-docs)

## What You'll Build

In this quickstart, you'll create a simple but powerful demonstration of private storage:

1. **Builder Setup** : You (as a builder/application) will register for a Nillion API Key
2. **Create an Owned Collection** : Define an owned collection with a specific schema that users can store private data in
3. **User Data Storage** - A user will store their private data in your collection and grant you limited access to it
This showcases Nillion's core value: users own their data, but can selectively share it with applications.

## What You'll Learn

- How builders create **owned collections** for user data
- How users store private data with **individual access controls**
- How to grant and revoke specific permissions (read/write/execute)
- How the **@nillion/secretvaults** library handles encryption and share distribution automatically

## Prerequisites

### 1. Get Your API Key and Subscription

As good practice, we recommend to use two distinct keys: one for network access and a separate key for subscription payments. This dual-key architecture separates authentication from payment processing, enhancing security by limiting the scope of each credential.

i

### Get your Nillion API keys here

Visit the Nillion subscription portal to get your API keys for secretvaults!

[Get your keys](https://subscription.nillion.com)

1. Create a Testnet public/private key pair through the UI that we will use for network access
2. [Fund your account with Testnet NIL](https://faucet.testnet.nillion.com)
3. Subscribe to `nilDB` by paying with your subscription wallet
4. Save your private key (hex format) - you'll need this for authentication

### 2. System Requirements

- `Node.js 22+` with ES modules support
- `pnpm` package manager (you can use `npm` or `yarn` as well)

## Project Setup

Create a new `Node.js` project:

```bash
mkdir nillion-secretvaults-demo
cd nillion-secretvaults-demo
pnpm init
```

Add ES module support to your `package.json` by adding:

```json
{
  "type": "module"
}
```

## Install Dependencies

Install the required Nillion packages:

```bash
pnpm add @nillion/secretvaults@latest @nillion/nuc dotenv
```

## Environment Configuration

Create a `.env` file in your project root:

```bash
# .env
BUILDER_PRIVATE_KEY=your-hex-private-key-from-nilpay

# Optional: Override default testnet URLs if needed
# NILCHAIN_URL=http://rpc.testnet.nilchain-rpc-proxy.nilogy.xyz
# NILAUTH_URL=https://nilauth.sandbox.app-cluster.sandbox.nilogy.xyz
# NILDB_NODES=https://nildb-stg-n1.nillion.network,https://nildb-stg-n2.nillion.network,https://nildb-stg-n3.nillion.network
```

**‚ö†Ô∏è Important** : Add `.env` to your `.gitignore` to avoid committing your private key!

## Basic Script Structure

Create `demo.js` with the following structure:

```javascript
#!/usr/bin/env node

import { randomUUID } from 'node:crypto';
import { config as loadEnv } from 'dotenv';

// Load environment variables
loadEnv();

// Import Nillion SDK components
import {
  Keypair,
  NilauthClient,
  PayerBuilder,
  NucTokenBuilder,
  Command,
} from '@nillion/nuc';
import {
  SecretVaultBuilderClient,
  SecretVaultUserClient,
} from '@nillion/secretvaults';

// Configuration
const config = {
  NILCHAIN_URL: process.env.NILCHAIN_URL,
  NILAUTH_URL: process.env.NILAUTH_URL,
  NILDB_NODES: process.env.NILDB_NODES.split(','),
  BUILDER_PRIVATE_KEY: process.env.BUILDER_PRIVATE_KEY,
};

// Validate configuration
if (!config.BUILDER_PRIVATE_KEY) {
  console.error('‚ùå Please set BUILDER_PRIVATE_KEY in your .env file');
  process.exit(1);
}

async function main() {
  // All code in the next steps will be added here
}

main().catch(console.error);
```

## Authentication and Client Setup

### Create Keypairs

```javascript
// Step 1: Create keypairs for builder and user
const builderKeypair = Keypair.from(config.BUILDER_PRIVATE_KEY); // Use your funded key
const userKeypair = Keypair.generate(); // Generate random user

const builderDid = builderKeypair.toDid().toString();
const userDid = userKeypair.toDid().toString();

console.log('Builder DID:', builderDid);
console.log('User DID:', userDid);
```

### Setup Authentication

```javascript
// Step 2: Create payer and nilauth client
const payer = await new PayerBuilder()
  .keypair(builderKeypair)
  .chainUrl(config.NILCHAIN_URL)
  .build();

const nilauth = await NilauthClient.from(config.NILAUTH_URL, payer);
```

### Initialize Builder Client

```javascript
// Step 3: Create builder client
const builder = await SecretVaultBuilderClient.from({
  keypair: builderKeypair,
  urls: {
    chain: config.NILCHAIN_URL,
    auth: config.NILAUTH_URL,
    dbs: config.NILDB_NODES,
  },
});

// Refresh token using existing subscription
await builder.refreshRootToken();
```

## Builder Registration

Handle builder registration with proper error handling:

```javascript
// Step 4: Register builder (handle existing registration)
try {
  const existingProfile = await builder.readProfile();
  console.log('‚úÖ Builder already registered:', existingProfile.data.name);
} catch (profileError) {
  try {
    await builder.register({
      did: builderDid,
      name: 'My Demo Builder',
    });
    console.log('‚úÖ Builder registered successfully');
  } catch (registerError) {
    // Handle duplicate key errors gracefully
    if (registerError.message.includes('duplicate key')) {
      console.log('‚úÖ Builder already registered (duplicate key)');
    } else {
      throw registerError;
    }
  }
}
```

## Create an Owned Collection

### Define Collection Schema

An **owned collection** allows users to store their private data with individual access controls on each record.

```javascript
// Step 5: Define your owned collection
const collectionId = randomUUID();

const collection = {
  _id: collectionId,
  type: 'owned', // Every document in the collection will be user-owned
  name: 'User Profile Collection',
  schema: {
      $schema: 'http://json-schema.org/draft-07/schema#',
      type: 'array',
      uniqueItems: true,
      items: {
      type: 'object',
      properties: {
          _id: { type: 'string', format: 'uuid' },
          name: { type: 'string' }, // name will not be secret shared
          email: { // email will be secret shared
            type: "object",
            properties: {
              "%share": {
                type: "string"
              }
            },
            required: [
              "%share"
            ]
          },
          phone: { // phone will be secret shared
            type: "object",
            properties: {
              "%share": {
                type: "string"
              }
            },
            required: [
              "%share"
            ]
          },
      },
      required: ['_id', 'name', 'email'],
      },
    },
  };
};
```

### Create Collection

```javascript
// Step 6: Create the owned collection
try {
  const createResults = await builder.createCollection(collection);
  console.log(
    '‚úÖ Owned collection created on',
    Object.keys(createResults).length,
    'nodes'
  );
} catch (error) {
  console.error('‚ùå Collection creation failed:', error.message);
  // Handle testnet infrastructure issues gracefully
}
```

## User Stores Private Data

### Create User Client

```javascript
// Step 7: Create user client
const user = await SecretVaultUserClient.from({
  baseUrls: config.NILDB_NODES,
  keypair: userKeypair,
  blindfold: {
    operation: 'store',
  },
});
```

### User Uploads Data with Access Control

```javascript
// Step 8: Builder grants write access to the user
const delegation = NucTokenBuilder.extending(builder.rootToken)
  .command(new Command(['nil', 'db', 'data', 'create']))
  .audience(userKeypair.toDid())
  .expiresAt(Math.floor(Date.now() / 1000) + 3600) // 1 hour
  .build(builderKeypair.privateKey());

// User's private data
// %allot indicates that the client should encrypt this data
const userPrivateData = {
  _id: randomUUID(),
  name: 'Steph',
  email: {
    '%allot': 'steph@example.com',
  },
  phone: {
    '%allot': '+1-555-0123',
  },
};

// User uploads data and grants builder limited access
const uploadResults = await user.createData(delegation, {
  owner: userDid,
  acl: {
    grantee: builderDid, // Grant access to the builder
    read: true, // Builder can read the data
    write: false, // Builder cannot modify the data
    execute: true, // Builder can run queries on the data
  },
  collection: collectionId,
  data: [userPrivateData],
});

console.log('‚úÖ User uploaded private data with builder access granted');
```

## Builder Accesses User Data

### Read User's Data (with permission)

```javascript
// Step 9: Builder reads user's data (only works because user granted access)
const userData = await user.readData({
  collection: collectionId,
  document: userPrivateData._id,
});

console.log('‚úÖ Builder successfully accessed user data:', {
  name: userData.data.name,
  email: userData.data.email,
  // Note: Builder can only see this because user granted read permission
});
```

### List User's Data References

```javascript
// Step 10: See what data the user has stored
const references = await user.listDataReferences();
console.log('‚úÖ User has', references.data.length, 'private records stored');
```

## Access Control in Action

### Grant Access to Another Builders

If users wants to grant access to other builders, they can do so by calling `grantAccess` and specifying the new builder did, the document and collection and specific permissions. We will omit this step for simplicity, but the code should look similar to this:

```javascript
// If you want to run this functionality
await user.grantAccess({
  collection: collectionId,
  document: userPrivateData._id,
  acl: {
    grantee: 'new-builder-did',
    read: true, // New Builder can read
    write: false, // New Builder cannot modify
    execute: false, // New Builder cannot run queries
  },
});
```

### Revoking Access

In the same way, we can revoke access calling `revokeAccess` :

```javascript
await user.revokeAccess({
  grantee: 'new-builder-did',
  collection: collectionId,
  document: userPrivateData._id,
});
```

### Cleanup

```javascript
// Step 11: User deletes their data
await user.deleteData({
  collection: collectionId,
  document: userPrivateData._id,
});

console.log('‚úÖ User deleted their private data');
```

## Running Your Demo

Run the full script

```bash
node demo.js
```

## What Just Happened?

üéâ **Congratulations!** You just built a privacy-preserving application where:

1. **You (Builder)** created a secure collection for user data
2. **A User** stored their private information with automatic encryption and share distribution
3. **The User** granted you specific, limited access to their data
4. **You** could read the data only because the user gave permission
5. **The User** maintained full control - they could revoke access or delete their data at any time
This demonstrates the core principle of Nillion's private storage: **users own their data** , but can selectively share it with applications they trust.

?

#### Were you able to complete the quickstart?

## Key Concepts Learned

- **Owned Collections** : Collections where users control access to their individual records
- **Access Control Lists (ACLs)** : Fine-grained permissions (read/write/execute) on each data record
- **Encrypted Shares** : Your sensitive data is automatically split and distributed across multiple nodes
- **User Sovereignty** : Users maintain complete control over their private data and permissions

## Advanced Features

### Using Sensitive Field Encryption

```javascript
// Mark fields as sensitive for automatic encryption
const sensitiveData = {
  _id: randomUUID(),
  name: 'Steph', // Plaintext
  email: 'steph@example.com', // Plaintext
  phone: { '%allot': '+1-555-0123' }, // Encrypted field flag
};
```

### Query Operations

```javascript
// Create and run queries on encrypted data
const query = {
  _id: randomUUID(),
  name: 'Find Users by Name',
  collection: collectionId,
  variables: {
    searchName: {
      description: 'Name to search for',
      path: '$.pipeline[0].$match.name',
    },
  },
  pipeline: [{ $match: { name: '' } }, { $count: 'total' }],
};

await builder.createQuery(query);
```

### OpenAPI

You can access the OpenAPI specifications for any node by visiting the following URL pattern: `https://{endpoint}/openapi.json` , where `{endpoint}` is replaced with your specific node address. For instance, to view the API specs for the staging node, you would use: `https://nildb-stg-n1.nillion.network/openapi.json` .

## Next Steps

Now that you understand the basics of Nillion private storage, you can:

- Explore more complex collection schemas
- Implement query operations on encrypted data
- Build applications that respect user privacy by default

# Collection Explorer

URL: https://docs.nillion.com/build/private-storage/collection-explorer

[![Collection Explorer](/assets/images/collection_explorer_card-99c3bf346da96f2d0a8a8205d6688fef.png)](https://collection-explorer.nillion.com/)

The [Nillion Collection Explorer](https://collection-explorer.nillion.com) is a no-code builder tool for creating and managing Nillion Private Storage schemas, collections, and records. This web-based interface provides a UI abstraction that speeds up and simplifies development by allowing builders to interact with Nillion's private data storage infrastructure without requiring programming knowledge or command-line tools. Everything possible through the Collection Explorer is also available programmatically via the Nillion [Secretvaults SDK](/build/private-storage/secretvaults) .

## What is the Collection Explorer?

The Collection Explorer is your gateway to [Nillion Private Storage](/build/private-storage/overview) as a **builder** , where you can:

- **Create standard collections by building schemas** that define the structure and validation rules for your private data
- **Store and manage records** with automatic encryption for sensitive fields
- **Control data privacy** by marking specific fields as encrypted for distribution across nilDB nodes
This database management interface is specifically designed for privacy-preserving data storage across distributed clusters.

## Getting Started

### Set Your Nillion Network Configuration

i

### Prerequisite: having a Nillion API Key

You need a Nillion API Key with an active nilDB subscription to use the Collection Explorer tool.

[Get a Nillion API Key](https://subscription.nillion.com)

Once you have a Nillion API Key with an active nilDB subscription, go to the [Collection Explorer](https://collection-explorer.nillion.com/) and configure your connection to the Nillion Network:

1. Navigate to "‚öôÔ∏è Network Settings" in the navbar
2. Configure your nilDB Network settings:
- **Node endpoints** : Defaults to [nilDB Testnet nodes](/build/network-config#nildb-nodes)
- **nilAuth** : Uses Testnet nilAuth by default
- **nilChain** : Points to Testnet nilChain URL
3. **Node endpoints** : Defaults to [nilDB Testnet nodes](/build/network-config#nildb-nodes)
4. **nilAuth** : Uses Testnet nilAuth by default
5. **nilChain** : Points to Testnet nilChain URL
6. Enter your [Nillion API Key](/build/network-api-access) for authenticated access
7. Save your configuration - these settings will persist across Collection Explorer sessions
[![Set API Key](/assets/images/collection_explorer_set_nillion_api_key-5893af13023dccbae06db811d083da64.png)](https://collection-explorer.nillion.com/)

## Managing Collections

### View Your Collections

The Collections dashboard provides an overview of all collections where your builder DID is the owner:

- Browse all collections associated with your builder account
- **Search functionality** : Filter collections by name or collection ID for quick access
- View key metrics like record count and creation timestamps
- See collection types (standard or owned)
[![View Collections](/assets/images/collection_explorer_view_collections-cf611eda7bc83c6247e42cb62c119dc9.png)](https://collection-explorer.nillion.com/collections)

### Create New Collections

You have two options for creating collections, depending on your preference and technical expertise:

#### Option 1: Visual Schema Builder (Recommended)

The custom schema builder provides an intuitive, visual interface:

- **Field-by-field creation** : Add fields one by one using a graphical interface
- **Field type selection** : Choose from various data types (string, number, boolean, etc.)
- **Validation rules** : Set constraints like required fields, min/max values, and format requirements
- **Privacy controls** : Mark sensitive fields as "Secret" for automatic blindfold storage encryption and secret sharing across nilDB nodes
- **Live preview** : See your JSON Schema update in real-time as you build
- **Schema validation** : Automatic validation ensures your schema is properly formatted
[![Create Collection with the UI](/assets/images/collection_explorer_create_collection_ui-ce680a5113f0448e059fb10d7b09a23d.png)](https://collection-explorer.nillion.com/)

#### Option 2: JSON Schema Upload (for devs with existing JSON schema code)

If you already have a JSON Schema or prefer working with code:

- **Direct paste** : Copy and paste your existing JSON Schema code
- **Automatic validation** : The system validates your JSON Schema structure before creation
- **Error feedback** : Get immediate feedback on any schema formatting issues
- **Faster setup** : Skip the visual builder if you're comfortable with JSON
[![Create Collection by uploading json](/assets/images/collection_explorer_create_collection_json-2a3501b050c6906d006a273d5226bb67.png)](https://collection-explorer.nillion.com/)

## Working with Records and Schemas

### Managing Collection Records

Once you have a collection, you can fully manage its data:

[![View Records](/assets/images/collection_explorer_records-946b83be908ef8d928d9aeaffbe5e19e.png)](https://collection-explorer.nillion.com/)

**Collection Overview:**

- View collection metadata including name, unique collection ID, total record count, storage size, and creation/modification timestamps
- See collection type (standard or owned) and owner DID
**Record Management:**

- **Add new records** : Create records that automatically validate against your collection's schema
- **View existing records** : Browse all records in a table format with pagination
- **Edit records** : Modify existing records with real-time schema validation
- **Delete records** : Remove individual records or bulk delete multiple records
- **Privacy toggle** : Show/hide encrypted fields to protect sensitive information during viewing
**Collection Administration:**

- **Delete collections** : Remove entire collections when they're no longer needed (use with caution - collections are immutable once created)
- **Export options** : Copy collection data for backup or migration purposes

### Viewing and Managing Schemas

Understanding and modifying your collection's structure:

[![View Collection Schema](/assets/images/collection_explorer_view_schema-ddb5727dcea0e754067594937e63966d.png)](https://collection-explorer.nillion.com/)

- **Schema visualization** : See the complete JSON Schema that defines your collection's structure and validation rules
- **Copy functionality** : Easily copy schema JSON for use in other applications or for backup
- **Field analysis** : Review all field types, constraints, and privacy settings at a glance
- **Field type identification** : Distinguish between plaintext fields (stored as-is across nodes) and encrypted fields (split into shares across the cluster)
- **Validation rules** : Understand what data validation occurs when records are added or modified

## Next Steps

After familiarizing yourself with the Collection Explorer:

1. Create your first collection using sample data to understand the workflow
2. Experiment with different field types and encrypted field settings
3. Explore the JSON Schema output to understand how to integrate with applications
4. Check out the [Secretvaults SDK](/build/private-storage/secretvaults) documentation for programmatic access to your collections

# Passwordless Authentication with MetaMask & Nillion

URL: https://docs.nillion.com/build/private-storage/metamask-guide

## Introduction

This guide demonstrates how to build a passwordless authentication system using **MetaMask** for identity and **Nillion's Network User Credentials (NUC)** for secure, decentralized authentication. Instead of traditional passwords, users authenticate using their Ethereum wallet signatures.

## MetaMask for Decentralized Identity (DID)

### What is a DID?

A **Decentralized Identifier (DID)** is a globally unique identifier that doesn't require a centralized authority. In our implementation, MetaMask wallet signatures are used to generate a DID that uniquely identifies users across the Nillion network.

### What are NUCs (Network User Credentials)?

**NUCs** are Nillion's cryptographic credentials that enable:

- Passwordless authentication via wallet signatures
- Secure access to Nillion's privacy-preserving infrastructure
- Identity verification without storing passwords or sensitive data
The NUC SDK abstracts the complexity of cryptographic operations, providing a simple interface for Web3 authentication.

Full code on github [Here](https://github.com/geniusyinka/nillion-mm-demo)

```text
cd nillion-mm-demo
pnpm install
pnpm dev
```

## Step By Step Implementation

### Prerequisites

This guide assumes you have a nextjs app already set up. Otherwise install NextJS:

```bash
npx create-next-app@latest my-app --yes
```

Install the required dependencies:

```bash
npm install @nillion/nuc @nillion/secretvaults viem @tanstack/react-query
```

# Active NilDB Subcription

Head over to [subscription.nillion.com](https://subscription.nillion.com) and subscribe to Nildb.

### 1. Configure Nillion Network

Create a configuration file for Nillion network endpoints:

```typescript
// src/config.ts
export const NETWORK_CONFIG = {
  chainId: "nillion-chain-testnet-1",
  nilchain: "http://rpc.testnet.nilchain-rpc-proxy.nilogy.xyz",
  nilauth: "https://nilauth.sandbox.app-cluster.sandbox.nilogy.xyz",
  nildb: [
    "https://nildb-stg-n1.nillion.network",
    "https://nildb-stg-n2.nillion.network",
    "https://nildb-stg-n3.nillion.network",
  ],
};
```

### 2. Connect MetaMask & Create NUC Signer

Set up the MetaMask connection and NUC signer:

```typescript
// src/context/NillionContext.tsx
import { Signer } from "@nillion/nuc";
import { createWalletClient, custom } from "viem";
import { mainnet } from "viem/chains";

const connectMetaMask = async () => {
  if (!window.ethereum) {
    throw new Error("MetaMask not installed");
  }

  // Create wallet client with viem
  const walletClient = createWalletClient({
    chain: mainnet,
    transport: custom(window.ethereum),
  });

  const [account] = await walletClient.requestAddresses();

  // Create Nillion NUC Signer from MetaMask
  const nucSigner = Signer.fromWeb3({
    getAddress: async () => account,
    signTypedData: async (domain, types, message) => {
      return walletClient.signTypedData({
        account,
        domain,
        types,
        primaryType: Object.keys(types).find(k => k !== "EIP712Domain"),
        message,
      });
    },
  });

  // Generate DID from signer
  const did = await nucSigner.getDid();
  console.log("User DID:", did.didString);

  return { signer: nucSigner, did: did.didString, address: account };
};
```

### 3. Initialize Nillion Session

Use the NUC signer to authenticate with Nillion:

```typescript
// src/hooks/useNillionClient.ts
import { NillionClient } from "@nillion/secretvaults";
import { NETWORK_CONFIG } from "@/config";

async function initializeSession(signer: Signer) {
  const client = new NillionClient({
    signer,
    nilchain: NETWORK_CONFIG.nilchain,
    nilauth: NETWORK_CONFIG.nilauth,
    nildb: NETWORK_CONFIG.nildb,
  });

  // Initialize session - this authenticates the user
  await client.initialize();

  return client;
}
```

### 4. Register & Subscribe User

Complete the authentication flow by registering the user:

```typescript
// Register builder profile
async function registerBuilder(client: NillionClient) {
  await client.registerBuilder({
    name: "User",
    description: "Authenticated via MetaMask",
  });
}

// Subscribe to Nillion services
async function subscribe(client: NillionClient) {
  await client.subscribe({
    name: "notes_subscription",
    subscriptionType: "free",
  });
}
```

### 5. Login Flow (Returning Users)

For returning users with stored sessions:

```typescript
// src/hooks/useLoginMutation.ts
async function login(signer: Signer, rootToken: string, nildbTokens: object) {
  const client = new NillionClient({
    signer,
    nilchain: NETWORK_CONFIG.nilchain,
    nilauth: NETWORK_CONFIG.nilauth,
    nildb: NETWORK_CONFIG.nildb,
  });

  // Restore previous session
  await client.login({
    rootToken,
    nildbTokens,
  });

  return client;
}
```

### 6. Complete Authentication Flow

Wire everything together:

```typescript
// Simplified flow
async function authenticateUser() {
  // 1. Connect MetaMask & get NUC signer
  const { signer, did } = await connectMetaMask();
  
  // 2. Check if user has existing session
  const hasSession = checkLocalStorage();
  
  if (hasSession) {
    // Login with existing session
    await login(signer, storedRootToken, storedNildbTokens);
  } else {
    // Initialize new session
    const client = await initializeSession(signer);
    
    // Register and subscribe
    await registerBuilder(client);
    await subscribe(client);
    
    // Store session tokens
    saveToLocalStorage(client.tokens);
  }
  
  // User is now authenticated!
  return { did, authenticated: true };
}
```

## Key Benefits

‚úÖ **No Password Storage** - Users authenticate with cryptographic signatures
‚úÖ **Decentralized Identity** - DIDs are portable across applications
‚úÖ **Enhanced Security** - Leverages battle-tested wallet security
‚úÖ **Better UX** - One-click authentication for Web3 users
‚úÖ **Privacy-First** - Built on Nillion's privacy-preserving infrastructure

## Conclusion

This implementation demonstrates how **MetaMask** and **Nillion's NUC SDK** enable passwordless authentication in Web3 applications. By leveraging wallet signatures and decentralized identifiers, you can build secure, user-friendly authentication without the risks of traditional password systems.

The NUC abstraction handles all cryptographic complexity, allowing developers to focus on building great user experiences while maintaining the highest security standards.

Secretvaults SDK
warning

If you are using secretvaults-ts, please upgrade to at least version 0.1.7

secretvaults is an SDK that simplifies interacting with Private Storage nilDB nodes to create Nillion Private Storage collections, and store and retrieve encrypted records.
SDK versions
TypeScript SDK

secretvaults-ts is a TypeScript library for web and Node.js environments

    Installation and Usage Docs
    secretvaults-ts GitHub repository
    NPM package
    TypeDoc with classes, methods, and types documented
    Integration Guides for Node, NextJS, and React
    TypeScript Examples with Node, NextJS, and React example apps

Python SDK

secretvaults-py is a python library for server-side applications

    secretvaults-py GitHub repository
    PyPi package
    Python Examples

No-Code Alternative: Collection Explorer

If you prefer a visual interface, check out the Collection Explorer. This no-code web tool provides the same functionality as the Secretvaults SDK through an intuitive UI, allowing you to:

    Create and manage schemas, collections, and records without coding
    Build production-ready collections through a visual interface
    Export schemas for use in programmatic applications
    Enable non-technical team members to work directly with Nillion Private Storage

Collections and schemas created through the Collection Explorer are fully compatible with the Secretvaults SDK, giving you the flexibility to use whichever approach fits your workflow best.

# SecretVaults SDK TypeScript Docs

URL: https://docs.nillion.com/build/private-storage/ts-docs

warning
If you are using `secretvaults-ts` , please upgrade to at least version `0.1.7`

This guide shows how to get started building with the Nillion [secretvaults-ts](https://github.com/NillionNetwork/secretvaults-ts) SDK to build applications with Nillion Private Storage.

## Install Nillion Dependencies

```bash
npm install @nillion/secretvaults @nillion/nuc
```

## Builder Client Usage

SecretVaults SDK [SecretVaultBuilderClient](https://nillion.pub/secretvaults-ts/classes/SecretVaultBuilderClient.html) Usage

info

#### Prerequisites

Before building with the SecretVaults SDK, you need:

1. Nillion Wallet: [Create a wallet](/community/guides/nillion-wallet)
2. Testnet NIL: Get NIL tokens from the [Nillion faucet](/community/guides/testnet-faucet)
3. Get a [Nillion API Key](/build/network-api-access) with a subscription to nilDB

### Initialize a Builder Client

Initialize the client with your Nillion API Key and a valid nilDB subscription. Connect to [nilDB nodes](/build/network-config#nildb-nodes) of choice. Call `refreshRootToken()` after initialization to obtain authentication tokens.

- builder keypair: from your [Nillion API Key](/build/network-api-access)
- urls: [nilDB Network Config](/build/network-config#nildb-nodes)
- blindfold.operation: Set to 'store' operation for storing data
nildb/secretvaults-ts/sdk-examples/client-helpers.ts

```typescript
loading...
```

[View on GitHub](https://github.com/NillionNetwork/blind-module-examples/blob/main/nildb/secretvaults-ts/sdk-examples/client-helpers.ts#L17-L32
)

### Register Builder Profile

One-time setup to register your builder profile to the nilDB nodes. Checks if profile exists, creates one if needed, and handles duplicate registration errors.

- did: Decentralized identifier generated from your API key
- name: Display name that will be set for your builder profile
nildb/secretvaults-ts/sdk-examples/client-helpers.ts

```typescript
loading...
```

[View on GitHub](https://github.com/NillionNetwork/blind-module-examples/blob/main/nildb/secretvaults-ts/sdk-examples/client-helpers.ts#L36-L62
)

### Create Collection

Collections organize and validate your data according to the schema rules. Builders can create "standard" or "owned" collection types.

tip
You can use the [Collection Explorer Tool](https://collection-explorer.nillion.com/) to more easily build and validate a JSON schema for your collection.

#### Create Standard Collection

- Standard Collection
- contactBookSchema
nildb/secretvaults-ts/sdk-examples/standard-collections/create-standard-collection.ts

```typescript
loading...
```

[View on GitHub](https://github.com/NillionNetwork/blind-module-examples/blob/main/nildb/secretvaults-ts/sdk-examples/standard-collections/create-standard-collection.ts#L9-L16
)

nildb/secretvaults-ts/sdk-examples/schema-examples.ts

```typescript
loading...
```

[View on GitHub](https://github.com/NillionNetwork/blind-module-examples/blob/main/nildb/secretvaults-ts/sdk-examples/schema-examples.ts
)

#### Create Owned Collection

- Owned Collection
- contactBookSchema
nildb/secretvaults-ts/sdk-examples/owned-collections/create-owned-collection.ts

```typescript
loading...
```

[View on GitHub](https://github.com/NillionNetwork/blind-module-examples/blob/main/nildb/secretvaults-ts/sdk-examples/owned-collections/create-owned-collection.ts#L9-L16
)

nildb/secretvaults-ts/sdk-examples/schema-examples.ts

```typescript
loading...
```

[View on GitHub](https://github.com/NillionNetwork/blind-module-examples/blob/main/nildb/secretvaults-ts/sdk-examples/schema-examples.ts
)

### Read Collections

Gets the id, collection type, and name of all collections.

nildb/secretvaults-ts/sdk-examples/shared/read-collections.ts

```typescript
loading...
```

[View on GitHub](https://github.com/NillionNetwork/blind-module-examples/blob/main/nildb/secretvaults-ts/sdk-examples/shared/read-collections.ts#L7
)

### Create Records

Creates new records in a standard collection. Records must match the collection's JSON schema. Use %allot to mark fields for encryption.

- collection: ID of the target collection
- data: Array of record objects matching the schema
- %allot: Special field marker that encrypts the value
tip
Use the no-code [Collection Explorer Tool](https://collection-explorer.nillion.com/) to view the collection and schema

The collection page has an "Example Record Payload" button that will show you the data structure for a record in the collection.

nildb/secretvaults-ts/sdk-examples/standard-collections/create-standard-record.ts

```typescript
loading...
```

[View on GitHub](https://github.com/NillionNetwork/blind-module-examples/blob/main/nildb/secretvaults-ts/sdk-examples/standard-collections/create-standard-record.ts#L11-L26
)

### Read Records

Finds and retrieves records from a collection using filter criteria. Use the collection explorer to view collections and records.

- collection: ID of the collection to search
- filter: Query object to match records (e.g., by _id or other fields)
nildb/secretvaults-ts/sdk-examples/shared/read-collection.ts

```typescript
loading...
```

[View on GitHub](https://github.com/NillionNetwork/blind-module-examples/blob/main/nildb/secretvaults-ts/sdk-examples/shared/read-collection.ts#L8-L11
)

### Update Records

Updates existing records in a collection. Can modify both regular and encrypted fields using MongoDB-style update operators.

- collection: ID of the target collection
- filter: Query to match records for updating
- update: Update operations using $set, $unset, etc.
nildb/secretvaults-ts/sdk-examples/standard-collections/update-record.ts

```typescript
loading...
```

[View on GitHub](https://github.com/NillionNetwork/blind-module-examples/blob/main/nildb/secretvaults-ts/sdk-examples/standard-collections/update-record.ts#L10-L23
)

### Delete Records

Deletes records from a collection based on filter criteria. Use the collection explorer to verify deletions.

- collection: ID of the target collection
- filter: Query to match records for deletion
nildb/secretvaults-ts/sdk-examples/standard-collections/delete-record.ts

```typescript
loading...
```

[View on GitHub](https://github.com/NillionNetwork/blind-module-examples/blob/main/nildb/secretvaults-ts/sdk-examples/standard-collections/delete-record.ts#L9-L14
)

### Create Query

Creates a new saved query in the system using MongoDB-style aggregation pipeline syntax. Queries operate on plaintext fields only - they cannot query encrypted fields (those marked as secret). Queries can be used for simple filtering or complex operations like statistical analysis, data aggregation, and transformations. Once saved, queries can be parameterized with variables and reused across different executions.

tip
Queries support the full range of MongoDB aggregation operations on plaintext fields - from simple $match filters to complex statistical calculations using $group, $avg, $min, $max, and more. Encrypted fields cannot be queried. Reference the Query Examples section to see how to structure aggregation pipelines for string and number field queries.

- Create Age Query
- contactBookSchema
This creates a query for a collection with a plaintext `age` number field. You could create this query for a Contact Book Collection, which has `age` as a plaintext, optional number field.

```typescript
const queryId = randomUUID();
const queryRequest: CreateQueryRequest = {
  _id: queryId,
  collection: collectionId,
  name: 'Calculate Age Statistics',
  variables: {},
  pipeline: [
    {
      $match: {
        age: { $exists: true, $ne: null },
      },
    },
    {
      $group: {
        _id: null,
        averageAge: { $avg: '$age' },
        minAge: { $min: '$age' },
        maxAge: { $max: '$age' },
        totalWithAge: { $sum: 1 },
        standardDeviation: { $stdDevPop: '$age' },
      },
    },
  ],
};

const createResponse = await builderClient.createQuery(queryRequest);
```

nildb/secretvaults-ts/sdk-examples/schema-examples.ts

```typescript
loading...
```

[View on GitHub](https://github.com/NillionNetwork/blind-module-examples/blob/main/nildb/secretvaults-ts/sdk-examples/schema-examples.ts
)

### Run Query

Executes a saved query and retrieves the results. Query execution is asynchronous across distributed nodes, requiring polling to get the final results. You can pass variables to parameterize the query at runtime.

- _id: ID of the saved query to execute
- variables: Object containing values for any query variables defined in the saved query
- Polling: Results must be polled as queries execute asynchronously across nodes
- Timeout: Example shows polling for up to 30 seconds with exponential backoff
nildb/secretvaults-ts/sdk-examples/queries/run-query.ts

```typescript
loading...
```

[View on GitHub](https://github.com/NillionNetwork/blind-module-examples/blob/main/nildb/secretvaults-ts/sdk-examples/queries/run-query.ts#L9-L46
)

### Create Delegation Token

Creates a delegation token that allows a user client to perform operations on behalf of a builder client. Delegation tokens enable secure, time-limited access without sharing the builder's root credentials.

- audience(userDid): Specifies which user DID can use this token
- expiresAt: Unix timestamp when the token becomes invalid
- build(): Signs the token with the builder's private key
nildb/secretvaults-ts/sdk-examples/owned-collections/create-delegation-token.ts

```typescript
loading...
```

[View on GitHub](https://github.com/NillionNetwork/blind-module-examples/blob/main/nildb/secretvaults-ts/sdk-examples/owned-collections/create-delegation-token.ts#L20-L44
)

## User Client Usage

SecretVaults SDK [SecretVaultUserClient](https://nillion.pub/secretvaults-ts/classes/SecretVaultUserClient.html) Usage

### Generate a New User Keypair

Creates a new cryptographic keypair for user authentication and generates the corresponding decentralized identifier (DID).

nildb/secretvaults-ts/sdk-examples/nuc-helpers.ts

```typescript
loading...
```

[View on GitHub](https://github.com/NillionNetwork/blind-module-examples/blob/main/nildb/secretvaults-ts/sdk-examples/nuc-helpers.ts#L4-L7
)

### Initialize a User Client

Initialize the user client with their user keypair or get their `Keypair` from the user's private key.

- urls: [nilDB Network Config](/build/network-config#nildb-nodes)
- blindfold.operation: Set to 'store' operation for storing data
nildb/secretvaults-ts/sdk-examples/client-helpers.ts

```typescript
loading...
```

[View on GitHub](https://github.com/NillionNetwork/blind-module-examples/blob/main/nildb/secretvaults-ts/sdk-examples/client-helpers.ts#L79-L87
)

### Create Owned Records

Creates user-owned records with access control permissions. Unlike standard records, owned records have explicit ownership and can grant specific access rights to other users.

- owner: User ID that owns the data
- data: Array of record objects
- acl: Access control list defining permissions for other users (in this case the `granteeDid` )
- delegationToken: Token from the builder allowing the user to perform the operation on the builder's collection
nildb/secretvaults-ts/sdk-examples/owned-collections/create-owned-data.ts

```typescript
loading...
```

[View on GitHub](https://github.com/NillionNetwork/blind-module-examples/blob/main/nildb/secretvaults-ts/sdk-examples/owned-collections/create-owned-data.ts#L15-L53
)

### List Owned Records

Retrieves a list of all data references owned by the user client, showing which collections contain the user's data.

- listDataReferences(): Returns all data references for the authenticated user
- collection: ID of the collection containing the user's data
- document/record: ID of the specific record owned by the user
- builderClient: ID of the builder client that created the collection
nildb/secretvaults-ts/sdk-examples/owned-collections/list-owned-records.ts

```typescript
loading...
```

[View on GitHub](https://github.com/NillionNetwork/blind-module-examples/blob/main/nildb/secretvaults-ts/sdk-examples/owned-collections/list-owned-records.ts#L9-L25
)

### Read Owned Record

Retrieves a specific owned record by its ID from a collection. Only the record owner or users with granted read access can retrieve the data.

- collection: ID of the collection containing the record
- document: ID of the specific record to retrieve
- readData(): Fetches the record data with decrypted fields
nildb/secretvaults-ts/sdk-examples/owned-collections/read-owned-record.ts

```typescript
loading...
```

[View on GitHub](https://github.com/NillionNetwork/blind-module-examples/blob/main/nildb/secretvaults-ts/sdk-examples/owned-collections/read-owned-record.ts#L9-L14
)

### Delete Owned Record

Deletes a specific owned record from a collection. Only the record owner can delete their data.

- collection: ID of the collection containing the record
- document: ID of the specific record to delete
- deleteData(): Removes the record from the collection permanently
nildb/secretvaults-ts/sdk-examples/owned-collections/delete-owned-record.ts

```typescript
loading...
```

[View on GitHub](https://github.com/NillionNetwork/blind-module-examples/blob/main/nildb/secretvaults-ts/sdk-examples/owned-collections/delete-owned-record.ts#L9-L14
)

### Grant Access

Grants specific permissions to another user for accessing an owned record. The record owner can control read, write, and execute permissions.

- grantee: DID of the user receiving access permissions
- read/write/execute: Boolean flags for specific permission types
- collection: ID of the collection containing the record
- document: ID of the specific record to grant access to
nildb/secretvaults-ts/sdk-examples/owned-collections/grant-access.ts

```typescript
loading...
```

[View on GitHub](https://github.com/NillionNetwork/blind-module-examples/blob/main/nildb/secretvaults-ts/sdk-examples/owned-collections/grant-access.ts#L13-L27
)

### Revoke Access

Removes previously granted permissions from a user for accessing an owned record. Only the record owner can revoke access permissions.

- collection: ID of the collection containing the record
- document: ID of the specific record to revoke access from
- grantee: DID of the user whose access is being revoked
- revokeAccess(): Removes all permissions for the specified user
nildb/secretvaults-ts/sdk-examples/owned-collections/revoke-access.ts

```typescript
loading...
```

[View on GitHub](https://github.com/NillionNetwork/blind-module-examples/blob/main/nildb/secretvaults-ts/sdk-examples/owned-collections/revoke-access.ts#L19-L25
)

## Integration Examples

### Standard Collection Example

Complete workflow demonstrating standard collection operations: creating a collection, adding multiple records, updating data, deleting records, and viewing the final state.

Full Example Code
- Full Example
- contactBookSchema
nildb/secretvaults-ts/sdk-examples/standard-collections/full-example-standard.ts

```typescript
loading...
```

[View on GitHub](https://github.com/NillionNetwork/blind-module-examples/blob/main/nildb/secretvaults-ts/sdk-examples/standard-collections/full-example-standard.ts#L10-L108
)

nildb/secretvaults-ts/sdk-examples/schema-examples.ts

```typescript
loading...
```

[View on GitHub](https://github.com/NillionNetwork/blind-module-examples/blob/main/nildb/secretvaults-ts/sdk-examples/schema-examples.ts
)

### Owned Collection Example

Complete example demonstrating the full workflow for owned data collections: creating a user, delegation tokens, owned collections, and data with access control.

Full Example Code
- Full Example
- contactBookSchema
nildb/secretvaults-ts/sdk-examples/owned-collections/full-example-owned.ts

```typescript
loading...
```

[View on GitHub](https://github.com/NillionNetwork/blind-module-examples/blob/main/nildb/secretvaults-ts/sdk-examples/owned-collections/full-example-owned.ts#L10-L108
)

nildb/secretvaults-ts/sdk-examples/schema-examples.ts

```typescript
loading...
```

[View on GitHub](https://github.com/NillionNetwork/blind-module-examples/blob/main/nildb/secretvaults-ts/sdk-examples/schema-examples.ts
)

### Query Examples

Complete working examples demonstrating MongoDB-style aggregation queries on plaintext fields. Each example includes collection setup, sample data creation, multiple query types, and result processing. These show the full range of operations possible on unencrypted data in Private Storage.

#### Querying String Fields

Demonstrates text-based queries including exact matches, pattern matching with regex, case-insensitive searches, prefix/suffix filtering, and text aggregations. Examples use the plaintext `name` field from a contact book schema.

Querying String Fields Example Code
- Full Script
- String Queries
nildb/secretvaults-ts/sdk-examples/queries/plaintext-string-query-example.ts

```typescript
loading...
```

[View on GitHub](https://github.com/NillionNetwork/blind-module-examples/blob/main/nildb/secretvaults-ts/sdk-examples/queries/plaintext-string-query-example.ts
)

nildb/secretvaults-ts/sdk-examples/query-examples-string.ts

```typescript
loading...
```

[View on GitHub](https://github.com/NillionNetwork/blind-module-examples/blob/main/nildb/secretvaults-ts/sdk-examples/query-examples-string.ts
)

#### Querying Number Fields

Demonstrates numeric queries including exact values, range filtering, mathematical comparisons, statistical calculations (avg, min, max, standard deviation), grouping by numeric ranges, and sorting with pagination. Examples use the plaintext `age` field from a contact book schema.

Querying Number Fields Example Code
- Full Script
- Number Queries
nildb/secretvaults-ts/sdk-examples/queries/plaintext-number-query-example.ts

```typescript
loading...
```

[View on GitHub](https://github.com/NillionNetwork/blind-module-examples/blob/main/nildb/secretvaults-ts/sdk-examples/queries/plaintext-number-query-example.ts
)

nildb/secretvaults-ts/sdk-examples/query-examples-number.ts

```typescript
loading...
```

[View on GitHub](https://github.com/NillionNetwork/blind-module-examples/blob/main/nildb/secretvaults-ts/sdk-examples/query-examples-number.ts
)

## Full SDK Reference Docs

Complete TypeScript documentation for all methods and types is available at: [https://nillion.pub/secretvaults-ts/modules.html](https://nillion.pub/secretvaults-ts/modules.html)

### [SecretVaultBuilderClient](https://nillion.pub/secretvaults-ts/classes/SecretVaultBuilderClient.html)

- Class for standard data collections with comprehensive CRUD operations and collection management.
- Key Methods: `createCollection` , `createStandardData` , `findData` , `updateData` , `deleteData` , `register` , `readProfile` , `refreshRootToken` , `createQuery` , `runQuery`

### [SecretVaultUserClient](https://nillion.pub/secretvaults-ts/classes/SecretVaultUserClient.html)

- Class for user-owned data collections with data access control and permissions.
- Key Methods: `createData` , `readData` , `deleteData` , `grantAccess` , `revokeAccess` , `listDataReferences` , `readProfile`

### Available Types

The SDK includes comprehensive TypeScript types for all requests, responses, and data structures.

# Private Storage: Node.js Recipe

URL: https://docs.nillion.com/build/private-storage/platform-nodejs

Build a Node.js script that reads all records from a [Nillion Private Storage](/build/private-storage/overview) standard collection with full TypeScript support!

## What You'll Build

This guide walks you through creating a Node.js/TypeScript script that:

- Connects directly to 3 nilDB Testnet nodes to read data from Nillion Private Storage
- Reads all records from an existing Nillion Private Storage standard collection
- Displays the data in formatted JSON output
- Runs in any Node.js environment (servers, CI/CD, local development)
**Complete example:** View the [full source code](https://github.com/NillionNetwork/blind-module-examples/tree/main/nildb/secretvaults-ts/standard-collection/nodejs-script-recipe) for the finished Node.js script.

tip
This recipe is AI friendly! Give this entire [recipe markdown doc](https://github.com/NillionNetwork/nillion-docs/blob/main/docs/build/private-storage/platform-nodejs.md) to your LLM of choice and ask it to follow the recipe to read all records from your Nillion Private Storage standard collection. All you will have to do manually is complete the prerequisites below to set .env values.

### Prerequisites

Before starting this guide, you'll need:

1. **A Nillion API Key** - Follow the [Network API Access guide](/build/network-api-access) to get your API key and subscribe to nilDB services
2. **A Nillion Private Storage collection with data** - Use the [Collection Explorer](/build/private-storage/collection-explorer) to create collections and add records using the no-code builder

## Step 1: Create Project & Install Dependencies

First, we'll create a new Node.js project and install the Nillion libraries. No browser polyfills needed - Node.js has everything built-in!

```bash
mkdir my-nillion-app
cd my-nillion-app
npm init -y
```

Install Nillion dependencies and TypeScript tooling

```bash
npm install @nillion/nuc @nillion/secretvaults
npm install -D typescript @types/node tsx dotenv
```

## Step 2: Configure Your TypeScript Project

Set up TypeScript for modern Node.js development.

### 1. Create tsconfig.json

```json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ESNext",
    "lib": ["ES2022"],
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "moduleResolution": "node"
  }
}
```

### 2. Setup Environment Variables

**.env** - Store your configuration securely:

```bash
NILLION_API_KEY=your-api-key-here
NILLION_COLLECTION_ID=your-collection-id-here
```

### 3. Update .gitignore

Create a .gitignore file and add:

```text
node_modules/
.env
dist/
*.js
```

### 4. Add Package Scripts

**package.json** - Add convenient scripts for development and set the module type:

```json
{
  "name": "my-nillion-app",
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "dev": "tsx read-collection.ts",
    "build": "tsc",
    "start": "node read-collection.js"
  }
}
```

## Step 3: Build Your Nillion-Powered Node.js Script

Let's create a TypeScript script that connects to Nillion and reads your collection data.

### Create read-collection.ts

```typescript
import { Keypair } from '@nillion/nuc';
import { SecretVaultBuilderClient } from '@nillion/secretvaults';
import 'dotenv/config';

async function readAllRecords() {
  // Load environment variables
  const NILLION_API_KEY = process.env.NILLION_API_KEY;
  const NILLION_COLLECTION_ID = process.env.NILLION_COLLECTION_ID;

  // Validate environment variables
  if (!NILLION_API_KEY || !NILLION_COLLECTION_ID) {
    throw new Error(
      'Missing required environment variables: NILLION_API_KEY and NILLION_COLLECTION_ID'
    );
  }

  try {
    // get a Nillion API Key: https://docs.nillion.com/build/network-api-access
    // see Nillion Testnet Config: https://docs.nillion.com/build/network-config#nildb-nodes
    const builder = await SecretVaultBuilderClient.from({
      keypair: Keypair.from(NILLION_API_KEY),
      urls: {
        chain: 'http://rpc.testnet.nilchain-rpc-proxy.nilogy.xyz',
        auth: 'https://nilauth.sandbox.app-cluster.sandbox.nilogy.xyz',
        dbs: [
          'https://nildb-stg-n1.nillion.network',
          'https://nildb-stg-n2.nillion.network',
          'https://nildb-stg-n3.nillion.network',
        ],
      },
      blindfold: { operation: 'store' },
    });

    // Refresh authentication
    await builder.refreshRootToken();

    // Read all records from the collection
    const response = await builder.findData({
      collection: NILLION_COLLECTION_ID,
      filter: {}, // Empty filter returns all records
    });

    // Display results
    console.log(
      `Found ${response.data.length} records in collection ${NILLION_COLLECTION_ID}:`
    );
    console.log(JSON.stringify(response.data, null, 2));

    return response.data;
  } catch (error) {
    console.error('Error reading collection:', error);
    throw error;
  }
}

// Run the script
readAllRecords()
  .then(() => {
    console.log('Successfully read all records');
    process.exit(0);
  })
  .catch((error) => {
    console.error('Failed to read records:', error);
    process.exit(1);
  });
```

## üéâ That's It! Run Your Script

Execute your script and see Nillion in action:

```bash
npm run dev
```

Your Node.js script will connect to Nillion's testnet and display all records from your collection. If you haven't set up environment variables yet, you'll see a clear error message.

## Troubleshooting

- **"Missing environment variables" error** : Check your .env file exists
- **"hex string expected" error** : Verify your API key format
- **Module not found** : Ensure all dependencies are installed
- **TypeScript errors** : Make sure tsconfig.json is properly configured
- **Compatible with:** Node.js 18+, TypeScript 5+, ES Modules

## Next Steps: Add more functionality

This guide showed you how to read data from an existing collection in Nillion Private Storage. You can extend your app with many more capabilities using the complete SecretVaults SDK. The [TypeScript SDK Docs](/build/private-storage/ts-docs) provide methods and examples for programmatic Collection Management: Create, update, and organize your data collections

- [Create Collection](/build/private-storage/ts-docs#create-collection)
- [Create Records](/build/private-storage/ts-docs#create-records)
- [Find Records](/build/private-storage/ts-docs#read-records)
- [Update Records](/build/private-storage/ts-docs#update-records)
- [Delete Records](/build/private-storage/ts-docs#delete-records)
You can also explore the full [secretvaults-ts TypeDoc reference](https://nillion.pub/secretvaults-ts/) to discover all available operations for building complete applications with Nillion Private Storage.

- Advanced Data Operations: Add, modify, and delete records with sophisticated querying capabilities
- Real-time Features: Stream data updates and build responsive applications
- User Management: Handle registration, profiles, and authentication
- Performance Optimization: Index collections and optimize queries for better performance

# Blindfold Library

URL: https://docs.nillion.com/build/private-storage/blindfold

The blindfold cryptographic library provides functions for encrypting/decrypting and secret sharing data stored in individual nilDB nodes and nilDB clusters.

## How to use blindfold

For most developers and use cases, the [secretvaults SDKs](/build/private-storage/secretvaults) (which rely on blindfold) are sufficient. However, expert users may use blindfold to communicate directly with individual nilDB nodes and to manage on their own ciphertexts and secret shares within nilDB queries and replies.

### Via the secretvaults SDKs

The [secretvaults SDKs](/build/private-storage/secretvaults) provide common storage, retrieval, and querying functionalities for nilDB. The SDK abstracts away many aspects of data encryption/decryption and secret sharing (via blindfold) and communication with individual nodes in a cluster.

### As a Standalone Library

Developers can use blindfold as a general-purpose encryption/decryption library within their applications. Two versions of the library are available:

- TypeScript library for web and Node.js environments: [GitHub repository](https://github.com/NillionNetwork/blindfold-ts) and [NPM package](https://www.npmjs.com/package/@nillion/blindfold)
- Python library for server-side applications: [Read the Docs](https://blindfold.readthedocs.io) , [GitHub repository](https://github.com/NillionNetwork/blindfold-py) , and [PyPI package](https://pypi.org/project/blindfold/)
These libraries are entirely independent from nilDB. This means that developers are responsible for communicating with the individual nilDB nodes within a nilDB cluster, and for invoking blindfold functions as necessary to work with data and query replies.

## Supported Operations

This library supports traditional encryption of data for storage at rest, hashing of data for deterministic matching, homomorphic encryption of data in a manner that is compatible with addition under encryption, and secret sharing of data (via multi-party computation) in a manner that is compatible with summation under encryption. Each of these is compatible with either single-node clusters, multiple-node clusters, or both; the table below provides a detailed breakdown.

| Cluster | Operation | Implementation Details | Supported Types 
| single node | store | XSalsa20 stream cipher and Poly1305 MAC | 32-bit signed integer; UTF-8 string (4096 bytes or fewer) 
| single node | match | deterministic salted hashing via SHA-512 | 32-bit signed integer; UTF-8 string (4096 bytes or fewer) 
| single node | sum | non-deterministic Paillier with 2048-bit primes | 32-bit signed integer 
| multiple nodes | store | XOR-based secret sharing | 32-bit signed integer; UTF-8 string (4096 bytes or fewer) 
| multiple nodes | match | deterministic salted hashing via SHA-512 | 32-bit signed integer; UTF-8 string (4096 bytes or fewer) 
| multiple nodes | sum | additive secret sharing (no threshold; prime modulus 2^32 + 15) | 32-bit signed integer 
| multiple nodes | sum | Shamir's secret sharing (with threshold; prime modulus 2^32 + 15) | 32-bit signed integer
# Private LLMs with nilAI

URL: https://docs.nillion.com/build/private-llms/overview

## What are Private LLMs

Private LLMs are supported via a set of OpenAI-compatible APIs that run AI models within a *trusted execution environment* (TEE). This makes it possible to build new private AI applications or to migrate existing ones to run in a secure environment where your data remains private.

## How Private LLMs Work

1. Send your prompt over HTTPS (just like any secure web request)
2. Your prompt runs inside a Trusted Execution Environment where it is hidden from the cloud provider
3. Get your result back over HTTPS, complete with a cryptographic signature

## Available Models

| Model | Parameters | Features | Best For | Access 
| google/gemma-3-27b-it | 27B | Multimodal (text + images), 128K context, 140+ languages | Visual reasoning, long-context analysis, multilingual applications. | Testnet 
| openai/gpt-oss-20b | 20B | Chain-of-thought reasoning, tool calling, configurable effort levels | Agentic workflows, complex reasoning tasks. | [Apply for access](https://surveys.nillion.com/developers/7d516c7a-66ae-4c78-b927-bbd912ae7a16) 
| meta-llama/Llama-3.1-8B-Instruct | 8B | Chat completion, tool support | More complex tasks, detailed responses, code generation. Higher quality but slower inference. | [Apply for access](https://surveys.nillion.com/developers/7d516c7a-66ae-4c78-b927-bbd912ae7a16) 

## Key Features

- **Drop-in Privacy** : Keep your OpenAI-style code, just point it at a private LLM
- **Privacy Through TEEs** : All processing happens within a TEE, built on NVIDIA Confidential Computing
- **Standard Security** : HTTPS encryption provides end-to-end protection for all data in transit between your application and the TEE environment
- **Cryptographic Attestation** : Verify the integrity of your TEE environment through our attestation API
- **Signed Responses** : Every model response includes a cryptographic signature for verification

## Attestation & Verification

Two layers of cryptographic proof are provided:

1. **Environment Attestation** : Verify your TEE's integrity through the attestation endpoint, including:

- GPU environment verification
- Service verification through a verifying key
2. GPU environment verification
3. Service verification through a verifying key
4. **Response Signatures** : Every chat completion response includes a cryptographic signature, allowing you to verify that the response came from the attested environment.

## Getting Started

1. Get access to private LLMs by obtaining your nilAI API key and node URL
2. Use your API key to check the `/models` endpoint for available models
3. Start running private AI using your chosen model
4. Optionally, verify your environment using the attestation API

### Enhance by Providing Context from Private Storage and nilRAG

Optionally, you can use nilRAG to allow private LLMs to access nilDB private storage in order to retrieve relevant context! See [nilRAG documentation](/build/private-llms/nilRAG) for details.

# Quickstart

URL: https://docs.nillion.com/build/private-llms/quickstart

With nilAI, it is possible to run AI models within a trusted execution environment (TEE) via the secretLLM SDK. This makes it possible to build new private AI applications or migrate existing ones to run on a secure nilAI node so that your data remains private.

## Getting Started

In this quickstart, we will interact with a private AI chat/response application via Next.js. Let's get started by cloning our examples repo.

```text
gh repo clone NillionNetwork/blind-module-examples
cd blind-module-examples/nilai/secretllm_nextjs_nucs
```

## Authentication

```text
cp .env.example .env
```

Now we need to set `NILLION_API_KEY` using a key from the Nillion Subscription Portal below.

i

### Get your Nillion keys here

Visit the Nillion subscription portal to get your API keys for secretLLM!

[Get your keys](https://subscription.nillion.com)

## Usage

![secretLLM quickstart](/assets/images/secretllm-quickstart-eb71f58d077191f07f3fd3cbaec4687f.png)

We have two approaches for using the nilAI API via secretLLM:

- Direct API Access: Recommended for a solo developer/organization.
- Delegation Token: Provides permissions to another user or organization.

### Direct API Access

1. Get the API key from your `.env` file.
2. Check if the message and API key exist.
3. Initialize the nilAI OpenAI client with `baseURL` , `apiKey` , and `nilauthInstance` .
4. Make a request to the chat client with the `model` and `message` .
5. Receive the response from `message.content` .
nilai/secretllm_nextjs_nucs/app/api/chat/route.ts

```typescript
loading...
```

[View on GitHub](https://github.com/NillionNetwork/blind-module-examples/blob/main/nilai/secretllm_nextjs_nucs/app/api/chat/route.ts
)

### Delegation Token Access

1. Similar to Direct API access, except using `DELEGATION_TOKEN` authentication.
2. Server initializes a delegation token server.
3. Client produces a delegation request.
4. Server creates the delegation token.
5. Client uses the delegation token with the `model` and `message` for the request.
6. Response is delivered.
nilai/secretllm_nextjs_nucs/app/api/chat-delegation/route.ts

```typescript
loading...
```

[View on GitHub](https://github.com/NillionNetwork/blind-module-examples/blob/main/nilai/secretllm_nextjs_nucs/app/api/chat-delegation/route.ts
)

### Customization

You can also customize the types of models you want to use. Currently available models are listed [here.](/build/private-llms/overview#available-models)

## What you've done

üéâ **Congratulations!** You just built and interacted with a privacy‚Äëpreserving LLM application:

1. **You (Builder)** get access to the secretLLM SDK.
2. **You (User)** can provide a prompt to the LLM.
3. **The LLM** understands your prompt and returns an answer via direct or delegated access.
This demonstrates a core principle of private AI: you can create endless private AI applications via Nillion.

?

#### Were you able to complete the quickstart?

# Usage

URL: https://docs.nillion.com/build/private-llms/usage

Once you have [nilAI API access](/build/network-api-access) , you can start using LLMs on nilAI nodes with any OpenAI-compatible library.

## Getting Started with Private LLMs

- Python
- TypeScript

- pip
- uv

```bash
pip install nilai-py
```

```bash
uv pip install nilai-py
```

```bash
pnpm install @nillion/nilai-ts
```

You can either use:

- `API Key` flow as the sole developer / organization or
- `Delegation Flow` to provide permissions to another user / organization.

### API Key Flow

1. Use `https://nilai-a779.nillion.network/v1` as the BASE URL
2. Check [available models](/build/private-llms/overview#available-models) or query the [`/v1/models`](/api/nilai/get-models-v-1-models-get) endpoint or
3. Select an available model and use it with the [`/v1/chat/completions`](/api/nilai/chat-completion-v-1-chat-completions-post) nilAI node endpoint
With OpenAI compatibility, you can use any OpenAI library. Here's an example for querying the `gemma-3-27b-it` model:

- Python
- Typescript
nilai/secretllm_python_nucs/api_key_mode.py

```python
loading...
```

[View on GitHub](https://github.com/NillionNetwork/blind-module-examples/blob/main/nilai/secretllm_python_nucs/api_key_mode.py
)

```typescript
import "dotenv/config";
import { NilaiOpenAIClient, NilAuthInstance } from "@nillion/nilai-ts";

// To obtain an API key, navigate to https://subscription.nillion.com
// and create a new subscription.
// The API key will be displayed in the subscription details.
// The NilaiOpenAIClient class automatically handles the NUC token creation and management.

const API_KEY = process.env.NILLION_API_KEY;

async function main() {
// Initialize the client in API key mode
// For sandbox, use the following:
const client = new NilaiOpenAIClient({
    baseURL: "https://nilai-a779.nillion.network/v1/",
    apiKey: API_KEY,
    nilauthInstance: NilAuthInstance.SANDBOX,
    // For production, use the following:
    // nilauthInstance: NilAuthInstance.PRODUCTION,
});

// Make a request to the Nilai API
const response = await client.chat.completions.create({
    model: "google/gemma-3-27b-it",
    messages: [
    { role: "user", content: "Hello! Can you help me with something?" }
    ],
});

console.log(`Response: ${response.choices[0].message.content}`);
}

// Run the example
main().catch(console.error);
```

### Delegation flow

To use the delegation flow, you need to create a delegation token server.

The server then creates the delegation tokens and managing their expiration and usage. Then the delegation token allows you to make requests to the nilAI API.

- Python
- Typescript
nilai/secretllm_python_nucs/delegation_acess_mode.py

```python
loading...
```

[View on GitHub](https://github.com/NillionNetwork/blind-module-examples/blob/main/nilai/secretllm_python_nucs/delegation_acess_mode.py
)

examples/1-delegation-token.ts

```typescript
loading...
```

[View on GitHub](https://github.com/NillionNetwork/nilai-ts/blob/main/examples/1-delegation-token.ts
)

# Web Search

URL: https://docs.nillion.com/build/private-llms/advanced/web_search

Web search allows LLMs to access real-time information from the internet during inference. This enables the model to provide up-to-date answers based on current information rather than relying solely on its training data.

## Overview

To enable web search in your LLM requests, you need to:

1. Initialize a client with API key authentication
2. Add `web_search: true` to the `extra_body` parameter in your chat completion request
3. The model will automatically search the web and incorporate relevant information into its response

## Basic Usage

- Python
- TypeScript

```python
from nilai_py import Client, NilAuthInstance
from config import API_KEY

def main():
    # Initialize the client in API key mode
    client = Client(
        base_url="https://nilai-a779.nillion.network/nuc/v1/",
        api_key=API_KEY,
    )

    # Make a request with web search enabled
    response = client.chat.completions.create(
        model="google/gemma-3-27b-it",
        messages=[
            {
                "role": "user",
                "content": "Can you look for the latest news about AI and summarize them?",
            }
        ],
        extra_body={"web_search": True},
    )

    print(f"Response: {response.choices[0].message.content}")

if __name__ == "__main__":
    main()
```

```typescript
import "dotenv/config";
import { NilaiOpenAIClient, NilAuthInstance } from "@nillion/nilai-ts";

const API_KEY = process.env.NILLION_API_KEY;

async function main() {
  // Initialize the client in API key mode
  const client = new NilaiOpenAIClient({
    baseURL: "https://nilai-a779.nillion.network/v1/",
    apiKey: API_KEY,
    nilauthInstance: NilAuthInstance.SANDBOX,
    // For production, use the following:
    // nilauthInstance: NilAuthInstance.PRODUCTION,
  });

  // Make a request with web search enabled
  const response = await client.chat.completions.create(
    {
      model: "google/gemma-3-27b-it",
      messages: [
        {
          role: "user",
          content: "Hello! Can you help me understand the latest news of AI?",
        },
      ],
    },
    {
      extra_body: { web_search: true }, // Enable web search
    } as any,
  );

  console.log(`Response: ${response.choices[0].message.content}`);
}

main().catch(console.error);
```

## How It Works

When web search is enabled:

1. The model analyzes your query to determine if web search would be beneficial
2. If needed, it formulates search queries and retrieves relevant information from the web
3. The retrieved information is incorporated into the model's context
4. The model generates a response that combines its knowledge with the web-sourced information

## Use Cases

Web search is particularly useful for:

- **Current events** : Getting the latest news and updates
- **Real-time data** : Accessing current prices, statistics, or live information
- **Recent developments** : Information about topics that have evolved since the model's training cutoff
- **Fact verification** : Cross-referencing information with current sources
- **Dynamic content** : Queries that require up-to-date information

## Important Notes

- Web search adds latency to requests as the model needs to fetch and process external information
- The quality of responses depends on the relevance and accuracy of web sources found
- Not all queries will trigger a web search - the model determines when it's necessary
- Web search works with both API key and delegation token authentication flows

# Private Prompts

URL: https://docs.nillion.com/build/private-llms/advanced/private_prompts

warning
Private prompts are currently only available in **production mode** . Sandbox support is not yet available.

Private prompts allow you to store sensitive system prompts in nilDB (Nillion's decentralized database) and use them with LLM inference without exposing the prompt content. This is useful for protecting proprietary instructions, custom behaviors, or sensitive context.

## Overview

The private prompts flow involves:

1. **Storing prompts in nilDB** : Upload your prompt to nilDB and receive document IDs
2. **Setting up delegation** : Create a delegation token chain between the subscription owner and prompt data owner
3. **Using stored prompts** : Make LLM requests that reference the stored prompt without exposing its content

## Storing Prompts to nilDB

First, store your private prompt to nilDB. This returns document IDs and owner information.

- Python
- TypeScript

```python
from nilai_py import Client, NilAuthInstance
from config import API_KEY

def main():
    # Initialize the client in API key mode
    client = Client(
        base_url="https://nilai-xxxx.nillion.network/nuc/v1/",
        api_key=API_KEY,
        nilauth_instance=NilAuthInstance.PRODUCTION,
    )

    # List existing prompts from nilDB
    client.list_prompts_from_nilDB()

    # Store a new prompt to nilDB
    store_ids = client.store_prompt_to_nilDB(
        prompt="You are a very clever model that answers with cheese answers and always starting with the word cheese"
    )
    print("Stored document IDs:", store_ids)

    # List prompts again to verify
    client.list_prompts_from_nilDB()

if __name__ == "__main__":
    main()
```

```typescript
import "dotenv/config";
import {
  NilaiOpenAIClient,
  NilAuthInstance,
} from "@nillion/nilai-ts";
import { Did as DidClass } from "@nillion/nuc";

const API_KEY = process.env.NILLION_API_KEY;

async function store_to_nilDB(prompt: string): Promise<[string, string]> {
  // Initialize the client in API key mode
  const client = new NilaiOpenAIClient({
    baseURL: "https://nilai-xxxx.nillion.network/nuc/v1/",
    apiKey: API_KEY,
    nilauthInstance: NilAuthInstance.PRODUCTION,
  });

  const createdIds: string[] = await client.createPrompt(prompt);
  console.log(`Created IDS on nilDB: ${createdIds}`);

  const ownerDid = new DidClass(client.getKeypair()!.publicKey()).toString();
  return [createdIds[0], ownerDid];
}

async function main() {
  if (!API_KEY) {
    throw new Error("NILLION_API_KEY environment variable is required");
  }

  const [doc_id, owner_did] = await store_to_nilDB(
    "You are a very clever model that answers with cheese answers and always starting with the word cheese"
  );

  console.log(`Document ID: ${doc_id}`);
  console.log(`Owner DID: ${owner_did}`);
}

main().catch(console.error);
```

## Using Stored Prompts with Delegation

To use stored prompts, you need to set up a delegation token flow. This involves:

1. A **subscription owner server** that manages API access
2. A **prompt data owner server** that manages access to stored prompt documents
3. A **client** that makes requests using delegation tokens

- Python
- TypeScript
Key components of the implementation:

```python
from nilai_py import (
    Client,
    DelegationTokenServer,
    AuthType,
    DelegationServerConfig,
    NilAuthInstance,
    PromptDocumentInfo,
    DelegationTokenServerType,
)

# Create subscription owner server
subscription_owner_server = DelegationTokenServer(
    private_key=API_KEY,
    config=DelegationServerConfig(
        expiration_time=10 * 60 * 60,  # 10 hours
        token_max_uses=10,
    ),
    nilauth_instance=NilAuthInstance.PRODUCTION,
)

# Create prompt data owner server
prompt_data_owner_server = DelegationTokenServer(
    private_key=private_key,
    config=DelegationServerConfig(
        mode=DelegationTokenServerType.DELEGATION_ISSUER,
        expiration_time=10,  # 10 seconds
        token_max_uses=1,
        prompt_document=PromptDocumentInfo(
            doc_id=stored_prompt_data["doc_id"],
            owner_did=stored_prompt_data["did"]
        ),
    ),
    nilauth_instance=NilAuthInstance.PRODUCTION,
)

# Set up delegation chain
prompt_request = prompt_data_owner_server.get_delegation_request()
delegation_token = subscription_owner_server.create_delegation_token(prompt_request)
prompt_data_owner_server.update_delegation_token(delegation_token.delegation_token)

# Initialize client and set up delegation
client = Client(
    base_url="https://nilai-xxxx.nillion.network/nuc/v1/",
    auth_type=AuthType.DELEGATION_TOKEN,
    nilauth_instance=NilAuthInstance.PRODUCTION,
)

delegation_request = client.get_delegation_request()
delegation_token = prompt_data_owner_server.create_delegation_token(delegation_request)
client.update_delegation(delegation_token)

# Make request using stored prompt
response = client.chat.completions.create(
    model="openai/gpt-oss-20b",
    messages=[
        {"role": "user", "content": "Hello! Can you help me with something?"}
    ],
)

print(f"Response: {response.choices[0].message.content}")
```

Key components of the implementation:

```typescript
import {
  NilaiOpenAIClient,
  DelegationTokenServer,
  AuthType,
  type DelegationTokenRequest,
  type DelegationTokenResponse,
  NilAuthInstance,
} from "@nillion/nilai-ts";

const API_KEY = process.env.NILLION_API_KEY;

// First, store the prompt in nilDB (see previous section)
const [doc_id, owner_did] = await store_to_nilDB(
  "You are a very clever model that answers with cheese answers and always starting with the word cheese"
);

// Server initializes a delegation token server
const server = new DelegationTokenServer(API_KEY, {
  nilauthInstance: NilAuthInstance.PRODUCTION,
  expirationTime: 60 * 60, // 1 hour validity
  tokenMaxUses: 10,
  prompt_document: {
    owner_did: owner_did,
    doc_id: doc_id,
  },
});

// Client initializes without API key but with delegation auth
const client = new NilaiOpenAIClient({
  baseURL: "https://nilai-xxxx.nillion.network/nuc/v1/",
  authType: AuthType.DELEGATION_TOKEN,
  nilauthInstance: NilAuthInstance.PRODUCTION,
});

// Client produces a delegation request
const delegationRequest: DelegationTokenRequest =
  client.getDelegationRequest();

// Server creates a delegation token
const delegationToken: DelegationTokenResponse =
  await server.createDelegationToken(delegationRequest);

// Client sets the delegation token
client.updateDelegation(delegationToken);

// Client uses the delegation token to make a request
const response = await client.chat.completions.create({
  model: "openai/gpt-oss-20b",
  messages: [
    { role: "user", content: "Hello! Can you help me with something?" },
  ],
});

console.log(`Response: ${response.choices[0].message.content}`);
```

## Important Notes

- **Store private keys securely** : Keep private keys and stored prompt data in secure configuration files
- **Token expiration** : Set appropriate expiration times and usage limits for delegation tokens
- **Prompt storage only on NUCs** : Prompt delegation is only available for NUC authentication.

## Use Cases

Private prompts are ideal for:

- **Proprietary AI assistants** : Protect your custom system prompts and business logic
- **Sensitive instructions** : Keep confidential context or data handling rules private
- **Multi-tenant applications** : Different users can have different private prompts without exposing them
- **Compliance requirements** : Ensure sensitive prompts never leave the secure environment

# nilRAG Library

URL: https://docs.nillion.com/build/private-llms/nilRAG

Retrieval augmented generation (RAG) is a technique that grants large language models (LLMs) information retrieval capabilities and context that they might be missing. The nilRAG library leverages features of [Private LLMs](/build/private-llms/overview) and [Private Storage](/build/private-storage/overview) together with the [blindfold](/build/private-storage/blindfold) encryption library.

info
nilRAG makes it possible to store sensitive information in [Private Storage](/build/private-storage/overview) and then to use that information as context when leveraging the chat endpoint made available by [Private LLMs](/build/private-llms/overview) .

## Library Overview

Data owners often possess valuable files that clients wish to query to enhance their LLM-based inferences. However, ensuring privacy is a key challenge: data owners want to keep their data confidential, and clients are equally concerned about safeguarding their queries. nilRAG addresses this challenge by enabling secure data sharing and querying. It allows data owners to store their data securely in nilDB while allowing clients to query the data without exposing their queries or compromising the data's privacy. The process involves leveraging an LLM for secure computation via nilAI. Data owners upload their information to nilDB and an LLM on a nilAI node processes client queries and retrieves the most relevant results (top- *k* ) without revealing sensitive information from either party.

Let us do a deep dive into the entities and their roles in the system.

1. **Data Owners:** Securely upload files to nilDB. Before sending the files to nilDB, they are split up into multiple chunks of data and their corresponding embeddings. The embeddings are used for similarity search, while the chunks are used to retrieve the actual uploaded files. Once the files are encoded into chunks and embeddings, they are blinded before being uploaded to nilDB, where each chunk and embedding is stored in secret-shared form.

For instance, a data owner, wishes to upload the following file to nilDB and later use it to provide context to an LLM on a nilAI node:

Employees Example

```text
Kyle Moore works at Jackson, Gray and Lewis as a Economist. Kyle Moore was born on 1915-09-27 and lives at 6206 Caroline Point, Bishopland, MI 34522.

Charles Anderson works at Evans, Parker and Ramirez as a Surveyor, insurance. Charles Anderson was born on 2016-12-13 and lives at 0527 William Walk Suite 976, Lake Jason, MS 97840.

Danielle Miller works at Bailey and Sons as a Engineer, mining. Danielle Miller was born on 2007-10-22 and lives at 61586 Michael Greens, New Holly, CO 29872.
...
```

Let's dive a bit more into the example involving employee records. First, data owners need to create a schema and a query in nilDB using secretvaults:

init/bootstrap.py examples/init/bootstrap.py

```py
loading...
```

[View on GitHub](https://github.com/NillionNetwork/nilrag/blob/main/examples/init/bootstrap.py
)

Now that the schema and the query are ready, data owners can upload their data:

data_owner/write.py examples/data_owner/write.py

```py
loading...
```

[View on GitHub](https://github.com/NillionNetwork/nilrag/blob/main/examples/data_owner/write.py
)
2. **Client:** The client submits a query to search against the data owners' uploaded files using secretvaults, retrieves the most relevant data, and uses the top- *k* results for privacy-preserving inference with an LLM on a nilAI node. Using a similar encoding to that used by data owners, the query is transformed into its corresponding embeddings.

Going back to our example, the client can query an LLM on a nilAI node by asking about Danielle:

Employees Example

```text
Who is Danielle Miller?
```

Below is an example of how clients can run such a query:

client/query.py examples/client/query.py

```py
loading...
```

[View on GitHub](https://github.com/NillionNetwork/nilrag/blob/main/examples/client/query.py
)
3. **Private Storage:** The blinded chunks are stored and embeddings are provided by data owners. When a client submits a query, the differences between the query's embeddings and each stored embedding are computed in a privacy-preserving manner.
4. **Private LLMs:** An LLM on a nilAI node connects to nilDB to fetch the blinded differences between the query and the stored embeddings and then computes the closest matches. Finally, it uses the top- *k* matches for inference.

Finally, the client can query the LLM on nilAI by asking about Danielle:

Employees Example

```text
Danielle Miller is an engineer who works at Bailey and Sons, specializing in mining. She was born on October 22, 2007, and lives at 61586 Michael Greens, New Holly, CO 29872.
```
You can reproduce the example above by following the [README](https://github.com/NillionNetwork/nilrag) .

## Implementation

nilRAG is a standalone open-source library available on [PyPI](https://pypi.org/project/nilrag) and on [GitHub](https://github.com/NillionNetwork/nilrag) . Developers can use nilRAG as a feature of [Private LLMs](/build/private-llms/overview) to enhance the inference with context that has been uploaded to [Private Storage](/build/private-storage/overview) .

### Performance Expectations

Presented below are a series of benchmarks that evaluate the performance of nilRAG. Currently, nilRAG scales linearly to the number of rows stored in nilDB. The table shows latency to upload to nilDB multiple paragraphs of a few sentences long, as well as the runtime for AI inference using an LLM on a nilAI node with nilRAG.

| Number of Paragraphs Stored in nilDB | Upload Time to nilDB (sec.) | Query Time (Inference + RAG) (sec.) 
| 1 | 0.2 | 2.4 
| 10 | 0.4 | 3.1 
| 100 | 1.0 | 5.8 
| 1000 | 10.5 | 13.2 
| 10000 | 51.3 | 21.9 

Additionally, using multiple concurrent users, the query time for inference with nilRAG increases. Performing inference with nilRAG with a content of 100 paragraphs takes approximately 5 seconds for a single user, while with ten concurrent users the inference time for the same content goes up to almost 9 seconds. We are continuing our research to further accelerate nilRAG and make it more scalable. Stay tuned!

# Overview

URL: https://docs.nillion.com/api/nilai/overview

Each [nilAI node](/build/network-config#nilai-nodes) API provides the following endpoints for interfacing with [Private LLMs](/build/private-llms/overview) :

| Name | Endpoint | Description 
| Chat | [`/v1/chat/completions`](/api/nilai/chat-completion-v-1-chat-completions-post) | Generate AI responses 
| Models | [`/v1/models`](/api/nilai/get-models-v-1-models-get) | List available models 
| Attestation | [`/v1/attestation/report`](/api/nilai/get-attestation-v-1-attestation-report-get) | Get cryptographic proof of environment 
| Usage | [`/v1/usage`](/api/nilai/get-usage-v-1-usage-get) | Track your token usage 
| Health | [`/v1/health`](/api/nilai/health-check-v-1-health-get) | Check service status

Chat Completion

POST 
https://nilai-a779.nillion.network/v1/chat/completions

info

Feel free to use the Nillion2025 as a test Bearer Token

Generate a chat completion response from the AI model.

    req: Chat completion request containing messages and model specifications
    user: Authenticated user information (through HTTP Bearer header)
    Returns: Full chat response with model output, usage statistics, and cryptographic signature

Request Requirements

    Must include non-empty list of messages
    Must specify a model
    Supports multiple message formats (system, user, assistant)

Response Components

    Model-generated text completion
    Token usage metrics
    Cryptographically signed response for verification

Processing Steps

    Validate input request parameters
    Prepare messages for model processing
    Generate AI model response
    Track and update token usage
    Cryptographically sign the response

Potential HTTP Errors

    400 Bad Request:
        Missing messages list
        No model specified
    500 Internal Server Error:
        Model fails to generate a response

Request

    application/json

Body

    model
    Model (string)required
    messages
    object[]required
    temperature
    object
    top_p
    object
    max_tokens
    object
    stream
    object
    nilrag
    object

Responses

    200
    422

Successful Response

    application/json

    Schema

Schema

Authorization: http

    csharp
    curl
    dart
    go
    http
    java
    javascript
    kotlin
    c
    nodejs
    objective-c
    ocaml
    php
    powershell
    python
    r
    ruby
    rust
    shell
    swift

    HTTPCLIENT
    RESTSHARP

var client = new HttpClient();
var request = new HttpRequestMessage(HttpMethod.Post, "https://nilai-a779.nillion.network/v1/chat/completions");
request.Headers.Add("Accept", "application/json");
request.Headers.Add("Authorization", "Bearer <TOKEN>");
var content = new StringContent("{\n  \"model\": \"meta-llama/Llama-3.1-8B-Instruct\",\n  \"messages\": [\n    {\n      \"role\": \"system\",\n      \"content\": \"You are a helpful assistant\"\n    },\n    {\n      \"role\": \"user\",\n      \"content\": \"What is your name?\"\n    }\n  ],\n  \"temperature\": 0.2,\n  \"top_p\": 0.95,\n  \"max_tokens\": 2048,\n  \"stream\": false,\n  \"nilrag\": {}\n}", null, "application/json");
request.Content = content;
var response = await client.SendAsync(request);
response.EnsureSuccessStatusCode();
Console.WriteLine(await response.Content.ReadAsStringAsync());

Request Collapse all
Base URL
https://nilai-a779.nillion.network
Base URL
https://nilai-a779.nillion.network
Auth
Bearer Token
Body

{
  "model": "meta-llama/Llama-3.1-8B-Instruct",
  "messages": [
    {
      "role": "system",
      "content": "You are a helpful assistant"
    },
    {
      "role": "user",
      "content": "What is your name?"
    }
  ],
  "temperature": 0.2,
  "top_p": 0.95,
  "max_tokens": 2048,
  "stream": false,
  "nilrag": {}
}

ResponseClear

Click the Send API Request button above and see the response here!
Previous
Overview
Next
Attestation

# Chat Completion

URL: https://docs.nillion.com/api/nilai/chat-completion-v-1-chat-completions-post

```
POST
## https://nilai-a779.nillion.network /v1/chat/completions

```

info
Feel free to use the `Nillion2025` as a test Bearer Token

Generate a chat completion response from the AI model.

- **req** : Chat completion request containing messages and model specifications
- **user** : Authenticated user information (through HTTP Bearer header)
- **Returns** : Full chat response with model output, usage statistics, and cryptographic signature

### Request Requirements

- Must include non-empty list of messages
- Must specify a model
- Supports multiple message formats (system, user, assistant)

### Response Components

- Model-generated text completion
- Token usage metrics
- Cryptographically signed response for verification

### Processing Steps

1. Validate input request parameters
2. Prepare messages for model processing
3. Generate AI model response
4. Track and update token usage
5. Cryptographically sign the response

### Potential HTTP Errors

- **400 Bad Request** :
- Missing messages list
- No model specified
- **500 Internal Server Error** :
- Model fails to generate a response

## Request

- application/json

### Body

**model** Model (string)required

**messages** object[]required - Array [
**content** object anyOf
- MOD1
- MOD2

**** string

**refusal** object anyOf
- MOD1
- MOD2

**** string

**role** Role (string)required **Possible values:** [ `system` , `user` , `assistant` ]

**audio** object anyOf
- ChatCompletionAudio
- MOD2

**id** Id (string)required

**data** Data (string)required

**expires_at** Expires At (integer)required

**transcript** Transcript (string)required

**function_call** object anyOf
- FunctionCall
- MOD2

**arguments** Arguments (string)required

**name** Name (string)required

**tool_calls** object anyOf
- MOD1
- MOD2

- Array [
**id** Id (string)required

**function** objectrequired **arguments** Arguments (string)required

**name** Name (string)required

**property name*** any

**type** Type (string)required

- ]

- ]

**temperature** object anyOf
- MOD1
- MOD2

**** number

**top_p** object anyOf
- MOD1
- MOD2

**** number

**max_tokens** object anyOf
- MOD1
- MOD2

**** integer

**stream** object anyOf
- MOD1
- MOD2

**** boolean

**nilrag** object anyOf
- MOD1
- MOD2

**** object

## Responses

- 200
- 422

Successful Response

- application/json

- Schema

**Schema**

Validation Error

- application/json

- Schema
- Example (auto)

**Schema**

**detail** object[] - Array [
**loc** object[]required - Array [
anyOf
- MOD1
- MOD2

**** string

**** integer

- ]

**msg** Message (string)required

**type** Error Type (string)required

- ]

```json
{
  "detail": [
    {
      "loc": [
        "string",
        0
      ],
      "msg": "string",
      "type": "string"
    }
  ]
}
```

#### Authorization: http

```
**name:**[HTTPBearer](/api/nilai/nilai#authentication) **type:** http **scheme :** bearer
```

- csharp
- curl
- dart
- go
- http
- java
- javascript
- kotlin
- c
- nodejs
- objective-c
- ocaml
- php
- powershell
- python
- r
- ruby
- rust
- shell
- swift

- HTTPCLIENT
- RESTSHARP

```csharp
var client = new HttpClient();
var request = new HttpRequestMessage(HttpMethod.Post, "https://nilai-a779.nillion.network/v1/chat/completions");
request.Headers.Add("Accept", "application/json");
request.Headers.Add("Authorization", "Bearer <TOKEN>");
var content = new StringContent("{\n  \"model\": \"meta-llama/Llama-3.1-8B-Instruct\",\n  \"messages\": [\n    {\n      \"role\": \"system\",\n      \"content\": \"You are a helpful assistant\"\n    },\n    {\n      \"role\": \"user\",\n      \"content\": \"What is your name?\"\n    }\n  ],\n  \"temperature\": 0.2,\n  \"top_p\": 0.95,\n  \"max_tokens\": 2048,\n  \"stream\": false,\n  \"nilrag\": {}\n}", null, "application/json");
request.Content = content;
var response = await client.SendAsync(request);
response.EnsureSuccessStatusCode();
Console.WriteLine(await response.Content.ReadAsStringAsync());
```

Request Collapse all
Base URL https://nilai-a779.nillion.network

Auth Bearer Token

Body
```
{ "model" :"meta-llama/Llama-3.1-8B-Instruct" , "messages" :[ { "role" :"system" , "content" :"You are a helpful assistant" } , { "role" :"user" , "content" :"What is your name?" } ] , "temperature" :0.2 , "top_p" :0.95 , "max_tokens" :2048 , "stream" :false , "nilrag" :{ } }
```

Response Clear
Click the `Send API Request` button above and see the response here!

# Attestation

URL: https://docs.nillion.com/api/nilai/get-attestation-v-1-attestation-report-get

```
GET
## https://nilai-a779.nillion.network /v1/attestation/report

```

info
Feel free to use the `Nillion2025` as a test Bearer Token

Generate a cryptographic attestation report.

- **user** : Authenticated user information (through HTTP Bearer header)
- **Returns** : Attestation details for service verification

### Attestation Details

- `verifying_key` : Public key for cryptographic verification
- `cpu_attestation` : CPU environment verification
- `gpu_attestation` : GPU environment verification

### Security Note

Provides cryptographic proof of the service's integrity and environment.

## Responses

- 200

Successful Response

- application/json

- Schema
- Example (auto)

**Schema**

**verifying_key** Verifying Key (string)required

**cpu_attestation** Cpu Attestation (string)required

**gpu_attestation** Gpu Attestation (string)required

```json
{
  "verifying_key": "string",
  "cpu_attestation": "string",
  "gpu_attestation": "string"
}
```

#### Authorization: http

```
**name:**[HTTPBearer](/api/nilai/nilai#authentication) **type:** http **scheme :** bearer
```

- csharp
- curl
- dart
- go
- http
- java
- javascript
- kotlin
- c
- nodejs
- objective-c
- ocaml
- php
- powershell
- python
- r
- ruby
- rust
- shell
- swift

- HTTPCLIENT
- RESTSHARP

```csharp
var client = new HttpClient();
var request = new HttpRequestMessage(HttpMethod.Get, "https://nilai-a779.nillion.network/v1/attestation/report");
request.Headers.Add("Accept", "application/json");
request.Headers.Add("Authorization", "Bearer <TOKEN>");
var response = await client.SendAsync(request);
response.EnsureSuccessStatusCode();
Console.WriteLine(await response.Content.ReadAsStringAsync());
```

Request Collapse all
Base URL https://nilai-a779.nillion.network

Auth Bearer Token

Response Clear
Click the `Send API Request` button above and see the response here!

# Models

URL: https://docs.nillion.com/api/nilai/get-models-v-1-models-get

```
GET
## https://nilai-a779.nillion.network /v1/models

```

info
Feel free to use the `Nillion2025` as a test Bearer Token

List all available models in the system.

- **user** : Authenticated user information (through HTTP Bearer header)
- **Returns** : Dictionary of available models

### Example

```python
# Retrieves list of available models
models = await get_models(user)
```

## Responses

- 200

Successful Response

- application/json

- Schema
- Example (auto)

**Schema**

- Array [
**id** Id (string)

**name** Name (string)required

**version** Version (string)required

**description** Description (string)required

**author** Author (string)required

**license** License (string)required

**source** Source (string)required

**supported_features** string[]required

- ]

```json
[
  {
    "id": "string",
    "name": "string",
    "version": "string",
    "description": "string",
    "author": "string",
    "license": "string",
    "source": "string",
    "supported_features": [
      "string"
    ]
  }
]
```

#### Authorization: http

```
**name:**[HTTPBearer](/api/nilai/nilai#authentication) **type:** http **scheme :** bearer
```

- csharp
- curl
- dart
- go
- http
- java
- javascript
- kotlin
- c
- nodejs
- objective-c
- ocaml
- php
- powershell
- python
- r
- ruby
- rust
- shell
- swift

- HTTPCLIENT
- RESTSHARP

```csharp
var client = new HttpClient();
var request = new HttpRequestMessage(HttpMethod.Get, "https://nilai-a779.nillion.network/v1/models");
request.Headers.Add("Accept", "application/json");
request.Headers.Add("Authorization", "Bearer <TOKEN>");
var response = await client.SendAsync(request);
response.EnsureSuccessStatusCode();
Console.WriteLine(await response.Content.ReadAsStringAsync());
```

Request Collapse all
Base URL https://nilai-a779.nillion.network

Auth Bearer Token

Response Clear
Click the `Send API Request` button above and see the response here!

# Usage

URL: https://docs.nillion.com/api/nilai/get-usage-v-1-usage-get

```
GET
## https://nilai-a779.nillion.network /v1/usage

```

info
Feel free to use the `Nillion2025` as a test Bearer Token

Retrieve the current token usage for the authenticated user.

- **user** : Authenticated user information (through HTTP Bearer header)
- **Returns** : Usage statistics for the user's token consumption

### Example

```python
# Retrieves token usage for the logged-in user
usage = await get_usage(user)
```

## Responses

- 200

Successful Response

- application/json

- Schema
- Example (auto)

**Schema**

**completion_tokens** Completion Tokens (integer)required

**prompt_tokens** Prompt Tokens (integer)required

**total_tokens** Total Tokens (integer)required

**completion_tokens_details** object anyOf
- CompletionTokensDetails
- MOD2

**accepted_prediction_tokens** object anyOf
- MOD1
- MOD2

**** integer

**audio_tokens** object anyOf
- MOD1
- MOD2

**** integer

**reasoning_tokens** object anyOf
- MOD1
- MOD2

**** integer

**rejected_prediction_tokens** object anyOf
- MOD1
- MOD2

**** integer

**prompt_tokens_details** object anyOf
- PromptTokensDetails
- MOD2

**audio_tokens** object anyOf
- MOD1
- MOD2

**** integer

**cached_tokens** object anyOf
- MOD1
- MOD2

**** integer

**property name*** any

```json
{
  "completion_tokens": 0,
  "prompt_tokens": 0,
  "total_tokens": 0,
  "completion_tokens_details": {
    "accepted_prediction_tokens": 0,
    "audio_tokens": 0,
    "reasoning_tokens": 0,
    "rejected_prediction_tokens": 0
  },
  "prompt_tokens_details": {
    "audio_tokens": 0,
    "cached_tokens": 0
  }
}
```

#### Authorization: http

```
**name:**[HTTPBearer](/api/nilai/nilai#authentication) **type:** http **scheme :** bearer
```

- csharp
- curl
- dart
- go
- http
- java
- javascript
- kotlin
- c
- nodejs
- objective-c
- ocaml
- php
- powershell
- python
- r
- ruby
- rust
- shell
- swift

- HTTPCLIENT
- RESTSHARP

```csharp
var client = new HttpClient();
var request = new HttpRequestMessage(HttpMethod.Get, "https://nilai-a779.nillion.network/v1/usage");
request.Headers.Add("Accept", "application/json");
request.Headers.Add("Authorization", "Bearer <TOKEN>");
var response = await client.SendAsync(request);
response.EnsureSuccessStatusCode();
Console.WriteLine(await response.Content.ReadAsStringAsync());
```

Request Collapse all
Base URL https://nilai-a779.nillion.network

Auth Bearer Token

Response Clear
Click the `Send API Request` button above and see the response here!

Health

GET 
https://nilai-a779.nillion.network/v1/health

Perform a system health check.

    Returns: Current system health status and uptime

Health Check Details

    Provides a quick verification of system operational status
    Reports current system uptime

Status Indicators

    status: Indicates system operational condition
        "ok": System is functioning normally
    uptime: Duration the system has been running

Example

# Retrieve system health status
health = await health_check()
# Expect: HealthCheckResponse(status='ok', uptime=3600)

Responses

    200

Successful Response

    application/json

    Schema
    Example (auto)

Schema

    status
    Status (string)required
    uptime
    Uptime (string)required

    csharp
    curl
    dart
    go
    http
    java
    javascript
    kotlin
    c
    nodejs
    objective-c
    ocaml
    php
    powershell
    python
    r
    ruby
    rust
    shell
    swift

    HTTPCLIENT
    RESTSHARP

var client = new HttpClient();
var request = new HttpRequestMessage(HttpMethod.Get, "https://nilai-a779.nillion.network/v1/health");
request.Headers.Add("Accept", "application/json");
var response = await client.SendAsync(request);
response.EnsureSuccessStatusCode();
Console.WriteLine(await response.Content.ReadAsStringAsync());

Request Collapse all
Base URL
https://nilai-a779.nillion.network
Base URL
https://nilai-a779.nillion.network
ResponseClear

Click the Send API Request button above and see the response here!
